"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryPlanner = exports.MAX_COMPUTED_PLANS = void 0;
const federation_internals_1 = require("@apollo/federation-internals");
const query_graphs_1 = require("@apollo/query-graphs");
const graphql_1 = require("graphql");
const config_1 = require("./config");
const generateAllPlans_1 = require("./generateAllPlans");
const QueryPlan_1 = require("./QueryPlan");
const debug = (0, federation_internals_1.newDebugLogger)('plan');
const SIBLING_TYPENAME_KEY = 'sibling_typename';
exports.MAX_COMPUTED_PLANS = 10000;
const fetchCost = 1000;
const pipeliningCost = 100;
const defaultCostFunction = {
    onFetchGroup: (group) => (fetchCost + selectionCost(group.selection)),
    reduceParallel: (values) => parallelCost(values),
    reduceSequence: (values) => sequenceCost(values),
    reduceDeferred(_, value) {
        return value;
    },
    reduceDefer(nonDeferred, _, deferredValues) {
        return sequenceCost([nonDeferred, parallelCost(deferredValues)]);
    },
};
function parallelCost(values) {
    return sum(values);
}
function sequenceCost(stages) {
    return stages.reduceRight((acc, stage, idx) => (acc + (Math.max(1, idx * pipeliningCost) * stage)), 0);
}
class QueryPlanningTaversal {
    constructor(supergraphSchema, subgraphs, selectionSet, startFetchIdGen, hasDefers, variableDefinitions, statistics, startVertex, rootKind, costFunction, initialContext, excludedEdges = [], excludedConditions = []) {
        this.supergraphSchema = supergraphSchema;
        this.subgraphs = subgraphs;
        this.startFetchIdGen = startFetchIdGen;
        this.hasDefers = hasDefers;
        this.variableDefinitions = variableDefinitions;
        this.statistics = statistics;
        this.startVertex = startVertex;
        this.rootKind = rootKind;
        this.costFunction = costFunction;
        this.closedBranches = [];
        this.isTopLevel = (0, query_graphs_1.isRootVertex)(startVertex);
        this.conditionResolver = (0, query_graphs_1.cachingConditionResolver)(subgraphs, (edge, context, excludedEdges, excludedConditions) => this.resolveConditionPlan(edge, context, excludedEdges, excludedConditions));
        const initialPath = query_graphs_1.GraphPath.create(subgraphs, startVertex);
        const initialOptions = (0, query_graphs_1.createInitialOptions)(initialPath, initialContext, this.conditionResolver, excludedEdges, excludedConditions);
        this.stack = mapOptionsToSelections(selectionSet, initialOptions);
    }
    debugStack() {
        if (this.isTopLevel && debug.enabled) {
            debug.group('Query planning open branches:');
            for (const [selection, options] of this.stack) {
                debug.groupedValues(options, opt => `${(0, query_graphs_1.simultaneousPathsToString)(opt)}`, `${selection}:`);
            }
            debug.groupEnd();
        }
    }
    findBestPlan() {
        while (this.stack.length > 0) {
            this.debugStack();
            const [selection, options] = this.stack.pop();
            this.handleOpenBranch(selection, options);
        }
        this.computeBestPlanFromClosedBranches();
        return this.bestPlan;
    }
    handleOpenBranch(selection, options) {
        const operation = selection.element();
        debug.group(() => `Handling open branch: ${operation}`);
        let newOptions = [];
        for (const option of options) {
            const followupForOption = (0, query_graphs_1.advanceSimultaneousPathsWithOperation)(this.supergraphSchema, option, operation);
            if (!followupForOption) {
                continue;
            }
            if (followupForOption.length === 0) {
                if (operation.kind === 'FragmentElement') {
                    this.closedBranches.push(options.map((o) => o.paths.map(p => (0, query_graphs_1.terminateWithNonRequestedTypenameField)(p))));
                }
                debug.groupEnd(() => `Terminating branch with no possible results`);
                return;
            }
            newOptions = newOptions.concat(followupForOption);
        }
        if (newOptions.length === 0) {
            if (this.isTopLevel) {
                debug.groupEnd(() => `No valid options to advance ${selection} from ${(0, query_graphs_1.advanceOptionsToString)(options)}`);
                throw new Error(`Was not able to find any options for ${selection}: This shouldn't have happened.`);
            }
            else {
                this.stack.splice(0, this.stack.length);
                this.closedBranches.splice(0, this.closedBranches.length);
                debug.groupEnd(() => `No possible plan for ${selection} from ${(0, query_graphs_1.advanceOptionsToString)(options)}; terminating condition`);
                return;
            }
        }
        if (selection.selectionSet) {
            for (const branch of mapOptionsToSelections(selection.selectionSet, newOptions)) {
                this.stack.push(branch);
            }
            debug.groupEnd();
        }
        else {
            const updated = this.maybeEliminateStrictlyMoreCostlyPaths(newOptions);
            this.closedBranches.push(updated);
            debug.groupEnd(() => `Branch finished with ${updated.length} options`);
        }
    }
    maybeEliminateStrictlyMoreCostlyPaths(options) {
        if (options.length === 1) {
            return [options[0].paths];
        }
        const singlePathOptions = options.filter(opt => opt.paths.length === 1);
        if (singlePathOptions.length === 0) {
            return options.map(opt => opt.paths);
        }
        let minJumps = Number.MAX_SAFE_INTEGER;
        let withMinJumps = [];
        for (const option of singlePathOptions) {
            const jumps = option.paths[0].subgraphJumps();
            if (jumps < minJumps) {
                minJumps = jumps;
                withMinJumps = [option.paths];
            }
            else if (jumps === minJumps) {
                withMinJumps.push(option.paths);
            }
        }
        for (const option of singlePathOptions.filter(opt => opt.paths.length > 1)) {
            const jumps = option.paths.reduce((acc, p) => Math.min(acc, p.subgraphJumps()), Number.MAX_SAFE_INTEGER);
            if (jumps <= minJumps) {
                withMinJumps.push(option.paths);
            }
        }
        return withMinJumps;
    }
    newDependencyGraph() {
        const rootType = this.isTopLevel && this.hasDefers ? this.supergraphSchema.schemaDefinition.rootType(this.rootKind) : undefined;
        return FetchDependencyGraph.create(this.supergraphSchema, this.subgraphs, this.startFetchIdGen, rootType);
    }
    reorderFirstBranch() {
        const firstBranch = this.closedBranches[0];
        let i = 1;
        while (i < this.closedBranches.length && this.closedBranches[i].length > firstBranch.length) {
            i++;
        }
        this.closedBranches[0] = this.closedBranches[i - 1];
        this.closedBranches[i - 1] = firstBranch;
    }
    pruneClosedBranches() {
        for (let i = 0; i < this.closedBranches.length; i++) {
            const branch = this.closedBranches[i];
            if (branch.length <= 1) {
                continue;
            }
            const pruned = [];
            for (const toCheck of branch) {
                if (!this.optionIsOverriden(toCheck, branch)) {
                    pruned.push(toCheck);
                }
            }
            this.closedBranches[i] = pruned;
        }
    }
    optionIsOverriden(toCheck, allOptions) {
        for (const option of allOptions) {
            if (toCheck === option) {
                continue;
            }
            if (toCheck.every((p) => option.some((o) => p.isOverriddenBy(o)))) {
                return true;
            }
        }
        return false;
    }
    computeBestPlanFromClosedBranches() {
        if (this.closedBranches.length === 0) {
            return;
        }
        this.pruneClosedBranches();
        this.closedBranches.sort((b1, b2) => b1.length > b2.length ? -1 : (b1.length < b2.length ? 1 : 0));
        let planCount = possiblePlans(this.closedBranches);
        debug.log(() => `Query has ${planCount} possible plans`);
        let firstBranch = this.closedBranches[0];
        while (planCount > exports.MAX_COMPUTED_PLANS && firstBranch.length > 1) {
            const prevSize = firstBranch.length;
            firstBranch.pop();
            planCount -= planCount / prevSize;
            this.reorderFirstBranch();
            firstBranch = this.closedBranches[0];
            debug.log(() => `Reduced plans to consider to ${planCount} plans`);
        }
        if (this.statistics) {
            this.statistics.evaluatedPlanCount += planCount;
        }
        debug.log(() => `All branches:${this.closedBranches.map((opts, i) => `\n${i}:${opts.map((opt => `\n - ${(0, query_graphs_1.simultaneousPathsToString)(opt)}`))}`)}`);
        let idxFirstOfLengthOne = 0;
        while (idxFirstOfLengthOne < this.closedBranches.length && this.closedBranches[idxFirstOfLengthOne].length > 1) {
            idxFirstOfLengthOne++;
        }
        let initialTree;
        let initialDependencyGraph;
        if (idxFirstOfLengthOne === this.closedBranches.length) {
            initialTree = query_graphs_1.PathTree.createOp(this.subgraphs, this.startVertex);
            initialDependencyGraph = this.newDependencyGraph();
        }
        else {
            initialTree = query_graphs_1.PathTree.createFromOpPaths(this.subgraphs, this.startVertex, this.closedBranches.slice(idxFirstOfLengthOne).flat(2));
            initialDependencyGraph = this.updatedDependencyGraph(this.newDependencyGraph(), initialTree);
            if (idxFirstOfLengthOne === 0) {
                this.bestPlan = [initialDependencyGraph, initialTree, this.cost(initialDependencyGraph)];
                return;
            }
        }
        const otherTrees = this.closedBranches.slice(0, idxFirstOfLengthOne).map(b => b.map(opt => query_graphs_1.PathTree.createFromOpPaths(this.subgraphs, this.startVertex, opt)));
        const { best, cost } = (0, generateAllPlans_1.generateAllPlansAndFindBest)({
            initial: { graph: initialDependencyGraph, tree: initialTree },
            toAdd: otherTrees,
            addFct: (p, t) => {
                const updatedDependencyGraph = p.graph.clone();
                this.updatedDependencyGraph(updatedDependencyGraph, t);
                const updatedTree = p.tree.merge(t);
                return { graph: updatedDependencyGraph, tree: updatedTree };
            },
            costFct: (p) => this.cost(p.graph),
            onPlan: (p, cost, prevCost) => {
                debug.log(() => {
                    if (!prevCost) {
                        return `Computed plan with cost ${cost}: ${p.tree}`;
                    }
                    else if (cost > prevCost) {
                        return `Found better with cost ${cost} (previous had cost ${prevCost}: ${p.tree}`;
                    }
                    else {
                        return `Ignoring plan with cost ${cost} (a better plan with cost ${prevCost} exists): ${p.tree}`;
                    }
                });
            },
        });
        this.bestPlan = [best.graph, best.tree, cost];
    }
    cost(dependencyGraph) {
        const { main, deferred } = dependencyGraph.process(this.costFunction, this.rootKind);
        return deferred.length === 0
            ? main
            : this.costFunction.reduceDefer(main, dependencyGraph.deferTracking.primarySelection, deferred);
    }
    updatedDependencyGraph(dependencyGraph, tree) {
        return (0, query_graphs_1.isRootPathTree)(tree)
            ? computeRootFetchGroups(dependencyGraph, tree, this.rootKind)
            : computeNonRootFetchGroups(dependencyGraph, tree, this.rootKind);
    }
    resolveConditionPlan(edge, context, excludedEdges, excludedConditions) {
        const bestPlan = new QueryPlanningTaversal(this.supergraphSchema, this.subgraphs, edge.conditions, 0, false, this.variableDefinitions, undefined, edge.head, 'query', this.costFunction, context, excludedEdges, (0, query_graphs_1.addConditionExclusion)(excludedConditions, edge.conditions)).findBestPlan();
        return bestPlan ? { satisfied: true, cost: bestPlan[2], pathTree: bestPlan[1] } : query_graphs_1.unsatisfiedConditionsResolution;
    }
}
class LazySelectionSet {
    constructor(_computed, _toCloneOnWrite) {
        this._computed = _computed;
        this._toCloneOnWrite = _toCloneOnWrite;
        (0, federation_internals_1.assert)(_computed || _toCloneOnWrite, 'Should have one of the argument');
    }
    parentType() {
        return this.forRead().parentType;
    }
    forRead() {
        return this._computed ? this._computed : this._toCloneOnWrite;
    }
    forWrite() {
        if (!this._computed) {
            this._computed = this._toCloneOnWrite.clone();
        }
        return this._computed;
    }
    clone() {
        if (this._computed) {
            return new LazySelectionSet(undefined, this._computed);
        }
        else {
            return this;
        }
    }
    toString() {
        return this.forRead().toString();
    }
}
class FetchGroup {
    constructor(dependencyGraph, index, subgraphName, rootKind, parentType, isEntityFetch, _selection, _inputs, mergeAt, deferRef) {
        this.dependencyGraph = dependencyGraph;
        this.index = index;
        this.subgraphName = subgraphName;
        this.rootKind = rootKind;
        this.parentType = parentType;
        this.isEntityFetch = isEntityFetch;
        this._selection = _selection;
        this._inputs = _inputs;
        this.mergeAt = mergeAt;
        this.deferRef = deferRef;
        this._parents = [];
        this._children = [];
        this.mustPreserveSelection = false;
        this.inputRewrites = [];
    }
    static create({ dependencyGraph, index, subgraphName, rootKind, parentType, inputsParentType, mergeAt, deferRef, }) {
        (0, federation_internals_1.assert)(parentType.schema() === dependencyGraph.subgraphSchemas.get(subgraphName), `Expected parent type ${parentType} to belong to ${subgraphName}`);
        (0, federation_internals_1.assert)(!inputsParentType || inputsParentType.schema() === dependencyGraph.supergraphSchema, `Expected inputs parent type ${inputsParentType} to belong to the supergraph schema`);
        return new FetchGroup(dependencyGraph, index, subgraphName, rootKind, parentType, !!inputsParentType, new LazySelectionSet(new federation_internals_1.SelectionSet(parentType)), inputsParentType ? new LazySelectionSet(new federation_internals_1.SelectionSet(inputsParentType)) : undefined, mergeAt, deferRef);
    }
    cloneShallow(newDependencyGraph) {
        var _a;
        return new FetchGroup(newDependencyGraph, this.index, this.subgraphName, this.rootKind, this.parentType, this.isEntityFetch, this._selection.clone(), (_a = this._inputs) === null || _a === void 0 ? void 0 : _a.clone(), this.mergeAt, this.deferRef);
    }
    set id(id) {
        (0, federation_internals_1.assert)(!this._id, () => `The id for fetch group ${this} is already set`);
        this._id = id;
    }
    get id() {
        return this._id;
    }
    get isTopLevel() {
        return !this.mergeAt;
    }
    get selection() {
        return this._selection.forRead();
    }
    get inputs() {
        var _a;
        return (_a = this._inputs) === null || _a === void 0 ? void 0 : _a.forRead();
    }
    addParents(parents) {
        for (const parent of parents) {
            this.addParent(parent);
        }
    }
    addParent(parent) {
        if (this.isChildOf(parent.group)) {
            return;
        }
        (0, federation_internals_1.assert)(!parent.group.isParentOf(this), () => `Group ${parent.group} is a parent of ${this}, but the child relationship is broken`);
        (0, federation_internals_1.assert)(!parent.group.isChildOf(this), () => `Group ${parent.group} is a child of ${this}: adding it as parent would create a cycle`);
        this.dependencyGraph.onModification();
        this._parents.push(parent);
        parent.group._children.push(this);
    }
    removeChild(child) {
        if (!this.isParentOf(child)) {
            return;
        }
        this.dependencyGraph.onModification();
        findAndRemoveInPlace((g) => g === child, this._children);
        findAndRemoveInPlace((p) => p.group === this, child._parents);
    }
    isParentOf(maybeChild) {
        return this._children.includes(maybeChild);
    }
    isChildOf(maybeParent) {
        return !!this.parentRelation(maybeParent);
    }
    isDescendantOf(maybeAncestor) {
        const children = Array.from(maybeAncestor.children());
        while (children.length > 0) {
            const child = children.pop();
            if (child === this) {
                return true;
            }
            child.children().forEach((c) => children.push(c));
        }
        return false;
    }
    isChildOfWithArtificialDependency(maybeParent) {
        var _a;
        const relation = this.parentRelation(maybeParent);
        if (!relation || ((_a = relation.path) === null || _a === void 0 ? void 0 : _a.length) !== 0) {
            return false;
        }
        if (!this.inputs) {
            return true;
        }
        return !!maybeParent.inputs && maybeParent.inputs.contains(this.inputs);
    }
    parentRelation(maybeParent) {
        return this._parents.find(({ group }) => maybeParent === group);
    }
    parents() {
        return this._parents;
    }
    parentGroups() {
        return this.parents().map((p) => p.group);
    }
    children() {
        return this._children;
    }
    addInputs(selection, rewrites) {
        (0, federation_internals_1.assert)(this._inputs, "Shouldn't try to add inputs to a root fetch group");
        const thisParentType = this._inputs.parentType();
        const schema = thisParentType.schema();
        const selectionParentType = selection.parentType;
        if (thisParentType.name !== selectionParentType.name && !(0, federation_internals_1.runtimeTypesIntersects)(thisParentType, selectionParentType)) {
            (0, federation_internals_1.assert)(this.isEntityFetch, `Cannot add ${selection} of parent type ${selectionParentType} to ${this._inputs} of parent type ${thisParentType}: no common runtime intersections and not an entity fetch`);
            const extractSelectedTypeName = (s) => {
                (0, federation_internals_1.assert)(s.kind === 'FragmentSelection', () => `Expected ${s} to be a fragment when adding inputs ${selection} to ${this}`);
                return s.element().castedType().name;
            };
            const typesToAccountFor = new Set(this._inputs.forRead().selections().map(extractSelectedTypeName).concat(selection instanceof federation_internals_1.SelectionSet
                ? selection.selections().map(extractSelectedTypeName)
                : [extractSelectedTypeName(selection)]));
            const allSupertypes = Array.from(typesToAccountFor).map((name) => (0, federation_internals_1.supertypes)(schema.type(name)));
            const first = allSupertypes[0];
            const rest = allSupertypes.slice(1);
            const commonType = first.find((t) => rest.every((st) => st.includes(t)));
            (0, federation_internals_1.assert)(commonType, () => `Cannot add ${selection} of parent type ${selectionParentType} to ${this._inputs} of parent type ${thisParentType}: non common supertype`);
            const newInputs = new federation_internals_1.SelectionSet(commonType);
            newInputs.mergeIn(this._inputs.forRead());
            this._inputs = new LazySelectionSet(newInputs);
        }
        if (selection instanceof federation_internals_1.SelectionSet) {
            this._inputs.forWrite().mergeIn(selection);
        }
        else {
            this._inputs.forWrite().add(selection);
        }
        if (rewrites) {
            rewrites.forEach((r) => this.inputRewrites.push(r));
        }
    }
    copyInputsOf(other, clone = false) {
        if (other.inputs) {
            this.addInputs(clone ? other.inputs.clone() : other.inputs, other.inputRewrites);
        }
    }
    addSelection(path, onPathEnd) {
        this._selection.forWrite().addPath(path, onPathEnd);
    }
    addSelections(selection) {
        this._selection.forWrite().mergeIn(selection);
    }
    canMergeChildIn(child) {
        var _a;
        return this.deferRef === child.deferRef && !!((_a = child.parentRelation(this)) === null || _a === void 0 ? void 0 : _a.path);
    }
    removeInputsFromSelection() {
        const inputs = this.inputs;
        if (inputs) {
            this._selection = new LazySelectionSet(this.selection.minus(inputs));
        }
    }
    isUseless() {
        if (!this.inputs || this.mustPreserveSelection) {
            return false;
        }
        const conditionInSupergraphIfInterfaceObject = (selection) => {
            if (selection.kind === 'FragmentSelection') {
                const condition = selection.element().typeCondition;
                if (condition && (0, federation_internals_1.isObjectType)(condition)) {
                    const conditionInSupergraph = this.dependencyGraph.supergraphSchema.type(condition.name);
                    (0, federation_internals_1.assert)(conditionInSupergraph, () => `Type ${condition.name} should exists in the supergraph`);
                    if ((0, federation_internals_1.isInterfaceType)(conditionInSupergraph)) {
                        return conditionInSupergraph;
                    }
                }
            }
            return undefined;
        };
        const inputSelections = this.inputs.selections();
        return this.selection.selections().every((selection) => {
            const conditionInSupergraph = conditionInSupergraphIfInterfaceObject(selection);
            if (!conditionInSupergraph) {
                return inputSelections.some((input) => input.contains(selection));
            }
            const implemTypeNames = conditionInSupergraph.possibleRuntimeTypes().map((t) => t.name);
            const interfaceInputSelections = [];
            const implementationInputSelections = [];
            for (const inputSelection of inputSelections) {
                (0, federation_internals_1.assert)(inputSelection.kind === 'FragmentSelection', () => `Unexpecting input selection ${inputSelection} on ${this}`);
                const inputCondition = inputSelection.element().typeCondition;
                (0, federation_internals_1.assert)(inputCondition, () => `Unexpecting input selection ${inputSelection} on ${this} (missing condition)`);
                if (inputCondition.name == conditionInSupergraph.name) {
                    interfaceInputSelections.push(inputSelection);
                }
                else if (implemTypeNames.includes(inputCondition.name)) {
                    implementationInputSelections.push(inputSelection);
                }
            }
            const subSelectionSet = selection.selectionSet;
            (0, federation_internals_1.assert)(subSelectionSet, () => `Should not be here for ${selection}`);
            if (interfaceInputSelections.length > 0) {
                return interfaceInputSelections.some((input) => input.selectionSet.contains(subSelectionSet));
            }
            return implementationInputSelections.length > 0
                && implementationInputSelections.every((input) => input.selectionSet.contains(subSelectionSet));
        });
    }
    mergeChildIn(child) {
        const relationToChild = child.parentRelation(this);
        (0, federation_internals_1.assert)(relationToChild, () => `Cannot merge ${child} into ${this}: the former is not a child of the latter`);
        const childPathInThis = relationToChild.path;
        (0, federation_internals_1.assert)(childPathInThis, () => `Cannot merge ${child} into ${this}: the path of the former into the later is unknown`);
        this.mergeInInternal(child, childPathInThis);
    }
    canMergeSiblingIn(sibling) {
        const ownParents = this.parents();
        const siblingParents = sibling.parents();
        return this.deferRef === sibling.deferRef
            && this.subgraphName === sibling.subgraphName
            && sameMergeAt(this.mergeAt, sibling.mergeAt)
            && ownParents.length === 1
            && siblingParents.length === 1
            && ownParents[0].group === siblingParents[0].group;
    }
    mergeSiblingIn(sibling) {
        this.copyInputsOf(sibling);
        this.mergeInInternal(sibling, []);
    }
    canMergeGrandChildIn(grandChild) {
        var _a;
        const gcParents = grandChild.parents();
        if (gcParents.length !== 1) {
            return false;
        }
        return this.deferRef === grandChild.deferRef && !!gcParents[0].path && !!((_a = gcParents[0].group.parentRelation(this)) === null || _a === void 0 ? void 0 : _a.path);
    }
    mergeGrandChildIn(grandChild) {
        const gcParents = grandChild.parents();
        (0, federation_internals_1.assert)(gcParents.length === 1, () => `Cannot merge ${grandChild} as it has multiple parents ([${gcParents}])`);
        const gcParent = gcParents[0];
        const gcGrandParent = gcParent.group.parentRelation(this);
        (0, federation_internals_1.assert)(gcGrandParent, () => `Cannot merge ${grandChild} into ${this}: the former parent (${gcParent.group}) is not a child of the latter`);
        (0, federation_internals_1.assert)(gcParent.path && gcGrandParent.path, () => `Cannot merge ${grandChild} into ${this}: some paths in parents are unknown`);
        this.mergeInInternal(grandChild, (0, federation_internals_1.concatOperationPaths)(gcGrandParent.path, gcParent.path));
    }
    mergeInWithAllDependencies(other) {
        var _a, _b;
        (0, federation_internals_1.assert)(this.deferRef === other.deferRef, () => `Can only merge unrelated groups within the same @defer block: cannot merge ${this} and ${other}`);
        (0, federation_internals_1.assert)(this.subgraphName === other.subgraphName, () => `Can only merge unrelated groups to the same subraphs: cannot merge ${this} and ${other}`);
        (0, federation_internals_1.assert)(sameMergeAt(this.mergeAt, other.mergeAt), () => `Can only merge unrelated groups at the same "mergeAt": ${this} has mergeAt=${this.mergeAt}, but ${other} has mergeAt=${other.mergeAt}`);
        (0, federation_internals_1.assert)(((_a = this.inputs) === null || _a === void 0 ? void 0 : _a.parentType) === ((_b = other.inputs) === null || _b === void 0 ? void 0 : _b.parentType), () => { var _a, _b; return `Can only merge unrelated groups with the same input parent type: ${this} has input parent=${(_a = this.inputs) === null || _a === void 0 ? void 0 : _a.parentType}, but ${other} has input parent=${(_b = other.inputs) === null || _b === void 0 ? void 0 : _b.parentType}`; });
        this.copyInputsOf(other);
        this.mergeInInternal(other, [], true);
    }
    mergeInInternal(merged, path, mergeParentDependencies = false) {
        (0, federation_internals_1.assert)(!merged.isTopLevel, "Shouldn't remove top level groups");
        const mergePathConditionalDirectives = (0, federation_internals_1.conditionalDirectivesInOperationPath)(path);
        let selectionSet;
        if (path.length === 0) {
            selectionSet = merged.selection;
        }
        else {
            selectionSet = new federation_internals_1.SelectionSet(this.selection.parentType);
            selectionSet.addPath(path, (endOfPathSet) => {
                (0, federation_internals_1.assert)(endOfPathSet, () => `Merge path ${path} ends on a non-selectable type`);
                for (const selection of merged.selection.selections()) {
                    const withoutUneededFragments = removeRedundantFragments(selection, endOfPathSet.parentType, mergePathConditionalDirectives);
                    addSelectionOrSelectionSet(endOfPathSet, withoutUneededFragments);
                }
            });
        }
        this._selection.forWrite().mergeIn(selectionSet);
        this.dependencyGraph.onModification();
        this.relocateChildrenOnMergedIn(merged, path);
        if (mergeParentDependencies) {
            this.relocateParentsOnMergedIn(merged);
        }
        if (merged.mustPreserveSelection) {
            this.mustPreserveSelection = true;
        }
        this.dependencyGraph.remove(merged);
    }
    removeUselessChild(child) {
        const relationToChild = child.parentRelation(this);
        (0, federation_internals_1.assert)(relationToChild, () => `Cannot remove useless ${child} of ${this}: the former is not a child of the latter`);
        const childPathInThis = relationToChild.path;
        (0, federation_internals_1.assert)(childPathInThis, () => `Cannot remove useless ${child} of ${this}: the path of the former into the later is unknown`);
        this.dependencyGraph.onModification();
        this.relocateChildrenOnMergedIn(child, childPathInThis);
        this.dependencyGraph.remove(child);
    }
    relocateChildrenOnMergedIn(merged, pathInThis) {
        var _a;
        for (const child of merged.children()) {
            if (this.isParentOf(child)) {
                continue;
            }
            const pathInMerged = (_a = child.parentRelation(merged)) === null || _a === void 0 ? void 0 : _a.path;
            child.addParent({ group: this, path: concatPathsInParents(pathInThis, pathInMerged) });
        }
    }
    relocateParentsOnMergedIn(merged) {
        for (const parent of merged.parents()) {
            if (parent.group.isParentOf(this)) {
                continue;
            }
            if (parent.group.isDescendantOf(this)) {
                continue;
            }
            this.addParent(parent);
        }
    }
    finalizeSelection() {
        addTypenameFieldForAbstractTypes(this.selection);
        const rewrites = [];
        addAliasesForNonMergingFields([{ path: [], selections: this.selection }], rewrites);
        this.selection.validate();
        return rewrites;
    }
    toPlanNode(queryPlannerConfig, variableDefinitions, fragments, operationName) {
        var _a;
        if (this.selection.isEmpty()) {
            return undefined;
        }
        const outputRewrites = this.finalizeSelection();
        const inputs = (_a = this._inputs) === null || _a === void 0 ? void 0 : _a.forRead();
        if (inputs) {
            inputs.validate();
        }
        const inputNodes = inputs ? inputs.toSelectionSetNode() : undefined;
        const subgraphSchema = this.dependencyGraph.subgraphSchemas.get(this.subgraphName);
        let operation = this.isEntityFetch
            ? operationForEntitiesFetch(subgraphSchema, this.selection, variableDefinitions, operationName)
            : operationForQueryFetch(subgraphSchema, this.rootKind, this.selection, variableDefinitions, operationName);
        operation = operation.optimize(fragments);
        const operationDocument = (0, federation_internals_1.operationToDocument)(operation);
        const fetchNode = {
            kind: 'Fetch',
            id: this.id,
            serviceName: this.subgraphName,
            requires: inputNodes ? (0, QueryPlan_1.trimSelectionNodes)(inputNodes.selections) : undefined,
            variableUsages: this.selection.usedVariables().map(v => v.name),
            operation: (0, graphql_1.stripIgnoredCharacters)((0, graphql_1.print)(operationDocument)),
            operationKind: schemaRootKindToOperationKind(operation.rootKind),
            operationName: operation.name,
            operationDocumentNode: queryPlannerConfig.exposeDocumentNodeInFetchNode ? operationDocument : undefined,
            inputRewrites: this.inputRewrites.length === 0 ? undefined : this.inputRewrites,
            outputRewrites: outputRewrites.length === 0 ? undefined : outputRewrites,
        };
        return this.isTopLevel
            ? fetchNode
            : {
                kind: 'Flatten',
                path: this.mergeAt,
                node: fetchNode,
            };
    }
    toString() {
        const base = `[${this.index}]${this.deferRef ? '(deferred)' : ''}${this._id ? `{id: ${this._id}}` : ''} ${this.subgraphName}`;
        return this.isTopLevel
            ? `${base}[${this._selection}]`
            : `${base}@(${this.mergeAt})[${this._inputs} => ${this._selection}]`;
    }
}
function genAliasName(baseName, unavailableNames) {
    let counter = 0;
    let candidate = `${baseName}__alias_${counter}`;
    while (unavailableNames.has(candidate)) {
        candidate = `${baseName}__alias_${++counter}`;
    }
    return candidate;
}
function typesCanBeMerged(t1, t2) {
    if ((0, federation_internals_1.isNonNullType)(t1)) {
        return (0, federation_internals_1.isNonNullType)(t2) ? typesCanBeMerged(t1.ofType, t2.ofType) : false;
    }
    if ((0, federation_internals_1.isListType)(t1)) {
        return (0, federation_internals_1.isListType)(t2) ? typesCanBeMerged(t1.ofType, t2.ofType) : false;
    }
    if ((0, federation_internals_1.isCompositeType)(t1)) {
        return (0, federation_internals_1.isCompositeType)(t2);
    }
    return (0, federation_internals_1.sameType)(t1, t2);
}
function addAliasesForNonMergingFields(selections, rewriteCollector) {
    const seenResponseNames = new Map();
    const rebasedFieldsInSet = (s) => (s.selections.fieldsInSet().map(({ path, field, directParent }) => ({ fieldPath: s.path.concat(path), field, directParent })));
    for (const { fieldPath, field, directParent } of selections.map((s) => rebasedFieldsInSet(s)).flat()) {
        const fieldName = field.element().name;
        const responseName = field.element().responseName();
        const fieldType = field.element().definition.type;
        const previous = seenResponseNames.get(responseName);
        if (previous) {
            if (previous.fieldName === fieldName && typesCanBeMerged(previous.fieldType, fieldType)) {
                if ((0, federation_internals_1.isCompositeType)((0, federation_internals_1.baseType)(fieldType))) {
                    (0, federation_internals_1.assert)(previous.selections, () => `Should have added selections for ${previous.fieldType}`);
                    const selections = previous.selections.concat({ path: fieldPath.concat(responseName), selections: field.selectionSet });
                    seenResponseNames.set(responseName, { ...previous, selections });
                }
            }
            else {
                const alias = genAliasName(responseName, seenResponseNames);
                const selections = field.selectionSet ? [{ path: fieldPath.concat(alias), selections: field.selectionSet }] : undefined;
                seenResponseNames.set(alias, { fieldName, fieldType, selections });
                const wasRemoved = directParent.removeTopLevelField(responseName);
                (0, federation_internals_1.assert)(wasRemoved, () => `Should have found and removed ${responseName} from ${directParent}`);
                directParent.add(field.withUpdatedField(field.element().withUpdatedAlias(alias)));
                rewriteCollector.push({
                    kind: 'KeyRenamer',
                    path: fieldPath.concat(alias),
                    renameKeyTo: responseName,
                });
            }
        }
        else {
            const selections = field.selectionSet ? [{ path: fieldPath.concat(responseName), selections: field.selectionSet }] : undefined;
            seenResponseNames.set(responseName, { fieldName, fieldType, selections });
        }
    }
    for (const selections of seenResponseNames.values()) {
        if (!selections.selections) {
            continue;
        }
        addAliasesForNonMergingFields(selections.selections, rewriteCollector);
    }
}
class DeferredInfo {
    constructor(label, path, parentType, deferred = new Set(), dependencies = new Set()) {
        this.label = label;
        this.path = path;
        this.parentType = parentType;
        this.deferred = deferred;
        this.dependencies = dependencies;
        this.subselection = new federation_internals_1.SelectionSet(parentType);
    }
}
const emptyDeferContext = {
    currentDeferRef: undefined,
    pathToDeferParent: [],
    activeDeferRef: undefined,
    isPartOfQuery: true,
};
function deferContextForConditions(baseContext) {
    return {
        ...baseContext,
        isPartOfQuery: false,
        currentDeferRef: baseContext.activeDeferRef,
    };
}
function deferContextAfterSubgraphJump(baseContext) {
    return baseContext.currentDeferRef === baseContext.activeDeferRef
        ? baseContext
        : {
            ...baseContext,
            activeDeferRef: baseContext.currentDeferRef,
        };
}
class GroupPath {
    constructor(fullPath, pathInGroup, responsePath) {
        this.fullPath = fullPath;
        this.pathInGroup = pathInGroup;
        this.responsePath = responsePath;
    }
    static empty() {
        return new GroupPath([], [], []);
    }
    inGroup() {
        return this.pathInGroup;
    }
    full() {
        return this.fullPath;
    }
    inResponse() {
        return this.responsePath;
    }
    forNewKeyFetch(newGroupContext) {
        return new GroupPath(this.fullPath, newGroupContext, this.responsePath);
    }
    forParentOfGroup(pathOfGroupInParent) {
        return new GroupPath(this.fullPath, (0, federation_internals_1.concatOperationPaths)(pathOfGroupInParent, this.pathInGroup), this.responsePath);
    }
    updatedResponsePath(element) {
        if (element.kind !== 'Field') {
            return this.responsePath;
        }
        let type = element.definition.type;
        const newPath = this.responsePath.concat(element.responseName());
        while (!(0, federation_internals_1.isNamedType)(type)) {
            if ((0, federation_internals_1.isListType)(type)) {
                newPath.push('@');
            }
            type = type.ofType;
        }
        return newPath;
    }
    add(element) {
        return new GroupPath(this.fullPath.concat(element), this.pathInGroup.concat(element), this.updatedResponsePath(element));
    }
    toString() {
        return `[${this.fullPath}]:[${this.pathInGroup}]`;
    }
}
class DeferTracking {
    constructor(rootType) {
        this.topLevelDeferred = new Set();
        this.deferred = new federation_internals_1.MapWithCachedArrays();
        this.primarySelection = rootType ? new federation_internals_1.SelectionSet(rootType) : undefined;
    }
    clone() {
        var _a, _b;
        const cloned = new DeferTracking((_a = this.primarySelection) === null || _a === void 0 ? void 0 : _a.parentType);
        this.topLevelDeferred.forEach((label) => cloned.topLevelDeferred.add(label));
        if (this.primarySelection) {
            (_b = cloned.primarySelection) === null || _b === void 0 ? void 0 : _b.mergeIn(this.primarySelection.clone());
        }
        for (const deferredBlock of this.deferred.values()) {
            const clonedInfo = new DeferredInfo(deferredBlock.label, deferredBlock.path, deferredBlock.parentType, new Set(deferredBlock.deferred));
            clonedInfo.subselection.mergeIn(deferredBlock.subselection.clone());
            cloned.deferred.set(deferredBlock.label, clonedInfo);
        }
        return cloned;
    }
    registerDefer({ deferContext, deferArgs, path, parentType, }) {
        if (!this.primarySelection) {
            return;
        }
        (0, federation_internals_1.assert)(deferArgs.label, 'All @defer should have be labelled at this point');
        let deferredBlock = this.deferred.get(deferArgs.label);
        if (!deferredBlock) {
            deferredBlock = new DeferredInfo(deferArgs.label, path, parentType);
            this.deferred.set(deferArgs.label, deferredBlock);
        }
        const parentRef = deferContext.currentDeferRef;
        if (!parentRef) {
            this.topLevelDeferred.add(deferArgs.label);
            this.primarySelection.addPath(deferContext.pathToDeferParent);
        }
        else {
            const parentInfo = this.deferred.get(parentRef);
            (0, federation_internals_1.assert)(parentInfo, `Cannot find info for parent ${parentRef} or ${deferArgs.label}`);
            parentInfo.deferred.add(deferArgs.label);
            parentInfo.subselection.addPath(deferContext.pathToDeferParent);
        }
    }
    updateSubselection(deferContext) {
        if (!this.primarySelection || !deferContext.isPartOfQuery) {
            return;
        }
        const parentRef = deferContext.currentDeferRef;
        if (parentRef) {
            const info = this.deferred.get(parentRef);
            (0, federation_internals_1.assert)(info, () => `Cannot find info for label ${parentRef}`);
            info.subselection.addPath(deferContext.pathToDeferParent);
        }
        else {
            this.primarySelection.addPath(deferContext.pathToDeferParent);
        }
    }
    getBlock(label) {
        return this.deferred.get(label);
    }
    addDependency(label, idDependency) {
        const info = this.deferred.get(label);
        (0, federation_internals_1.assert)(info, () => `Cannot find info for label ${label}`);
        info.dependencies.add(idDependency);
    }
    defersInParent(parentRef) {
        var _a;
        const labels = parentRef ? (_a = this.deferred.get(parentRef)) === null || _a === void 0 ? void 0 : _a.deferred : this.topLevelDeferred;
        return labels
            ? (0, federation_internals_1.setValues)(labels).map((label) => {
                const info = this.deferred.get(label);
                (0, federation_internals_1.assert)(info, () => `Should not have referenced ${label} without an existing info`);
                return info;
            })
            : [];
    }
}
class FetchDependencyGraph {
    constructor(supergraphSchema, subgraphSchemas, federatedQueryGraph, startingIdGen, rootGroups, groups, deferTracking) {
        this.supergraphSchema = supergraphSchema;
        this.subgraphSchemas = subgraphSchemas;
        this.federatedQueryGraph = federatedQueryGraph;
        this.startingIdGen = startingIdGen;
        this.rootGroups = rootGroups;
        this.groups = groups;
        this.deferTracking = deferTracking;
        this.isReduced = false;
        this.isOptimized = false;
        this.fetchIdGen = startingIdGen;
    }
    static create(supergraphSchema, federatedQueryGraph, startingIdGen, rootTypeForDefer) {
        return new FetchDependencyGraph(supergraphSchema, federatedQueryGraph.sources, federatedQueryGraph, startingIdGen, new federation_internals_1.MapWithCachedArrays(), [], new DeferTracking(rootTypeForDefer));
    }
    federationMetadata(subgraphName) {
        const schema = this.subgraphSchemas.get(subgraphName);
        (0, federation_internals_1.assert)(schema, () => `Unknown schema ${subgraphName}`);
        const metadata = (0, federation_internals_1.federationMetadata)(schema);
        (0, federation_internals_1.assert)(metadata, () => `Schema ${subgraphName} should be a federation subgraph`);
        return metadata;
    }
    nextFetchId() {
        return this.fetchIdGen;
    }
    clone() {
        const cloned = new FetchDependencyGraph(this.supergraphSchema, this.subgraphSchemas, this.federatedQueryGraph, this.startingIdGen, new federation_internals_1.MapWithCachedArrays(), new Array(this.groups.length), this.deferTracking.clone());
        for (const group of this.groups) {
            cloned.groups[group.index] = group.cloneShallow(cloned);
        }
        for (const root of this.rootGroups.values()) {
            cloned.rootGroups.set(root.subgraphName, cloned.groups[root.index]);
        }
        for (const group of this.groups) {
            const clonedGroup = cloned.groups[group.index];
            for (const parent of group.parents()) {
                clonedGroup.addParent({
                    group: cloned.groups[parent.group.index],
                    path: parent.path
                });
            }
        }
        return cloned;
    }
    getOrCreateRootFetchGroup({ subgraphName, rootKind, parentType, }) {
        let group = this.rootGroups.get(subgraphName);
        if (!group) {
            group = this.createRootFetchGroup({ subgraphName, rootKind, parentType });
            this.rootGroups.set(subgraphName, group);
        }
        return group;
    }
    rootSubgraphs() {
        return this.rootGroups.keys();
    }
    isRootGroup(group) {
        return group === this.rootGroups.get(group.subgraphName);
    }
    createRootFetchGroup({ subgraphName, rootKind, parentType, }) {
        const group = this.newFetchGroup({ subgraphName, parentType, rootKind });
        this.rootGroups.set(subgraphName, group);
        return group;
    }
    newFetchGroup({ subgraphName, parentType, inputsParentType, rootKind, mergeAt, deferRef, }) {
        this.onModification();
        const newGroup = FetchGroup.create({
            dependencyGraph: this,
            index: this.groups.length,
            subgraphName,
            rootKind,
            parentType,
            inputsParentType,
            mergeAt,
            deferRef,
        });
        this.groups.push(newGroup);
        return newGroup;
    }
    getOrCreateKeyFetchGroup({ subgraphName, inputsTypeName, mergeAt, type, parent, conditionsGroups, deferRef, }) {
        var _a, _b, _c;
        for (const existing of parent.group.children()) {
            if (existing.subgraphName === subgraphName
                && existing.mergeAt
                && sameMergeAt(existing.mergeAt, mergeAt)
                && inputsTypeName === ((_b = (_a = existing.inputs) === null || _a === void 0 ? void 0 : _a.parentType) === null || _b === void 0 ? void 0 : _b.name)
                && existing.selection.selections().every((s) => s.kind === 'FragmentSelection' && s.element().castedType() === type)
                && !this.isInGroupsOrTheirAncestors(existing, conditionsGroups)
                && existing.deferRef === deferRef) {
                const existingPathInParent = (_c = existing.parentRelation(parent.group)) === null || _c === void 0 ? void 0 : _c.path;
                if (!samePathsInParents(existingPathInParent, parent.path)) {
                    this.removePathInParent(parent.group, existing);
                }
                return existing;
            }
        }
        const newGroup = this.newKeyFetchGroup({
            subgraphName,
            inputsTypeName,
            mergeAt,
            deferRef
        });
        newGroup.addParent(parent);
        return newGroup;
    }
    removePathInParent(parent, child) {
        parent.removeChild(child);
        child.addParent({ group: parent });
    }
    newRootTypeFetchGroup({ subgraphName, rootKind, parentType, mergeAt, deferRef, }) {
        return this.newFetchGroup({
            subgraphName,
            parentType,
            rootKind,
            mergeAt,
            deferRef
        });
    }
    isInGroupsOrTheirAncestors(toCheck, conditions) {
        const stack = conditions.concat();
        while (stack.length > 0) {
            const group = stack.pop();
            if (toCheck === group) {
                return true;
            }
            stack.push(...group.parentGroups());
        }
        return false;
    }
    typeForFetchInputs(name) {
        const type = this.supergraphSchema.type(name);
        (0, federation_internals_1.assert)(type, `Type ${name} should exist in the supergraph`);
        (0, federation_internals_1.assert)((0, federation_internals_1.isCompositeType)(type), `Type ${type} should be a composite, but got ${type.kind}`);
        return type;
    }
    newKeyFetchGroup({ subgraphName, inputsTypeName, mergeAt, deferRef, }) {
        const parentType = this.federationMetadata(subgraphName).entityType();
        (0, federation_internals_1.assert)(parentType, () => `Subgraph ${subgraphName} has no entities defined`);
        return this.newFetchGroup({
            subgraphName,
            parentType,
            inputsParentType: this.typeForFetchInputs(inputsTypeName),
            rootKind: 'query',
            mergeAt,
            deferRef
        });
    }
    remove(toRemove) {
        this.onModification();
        const children = toRemove.children().concat();
        const parents = toRemove.parents().concat();
        for (const child of children) {
            (0, federation_internals_1.assert)(child.parents().length > 1, () => `Cannot remove ${toRemove} as it is the *only* parent of ${child}`);
            toRemove.removeChild(child);
        }
        for (const parent of parents) {
            parent.group.removeChild(toRemove);
        }
        this.groups.splice(toRemove.index, 1);
        for (let i = toRemove.index; i < this.groups.length; i++) {
            --this.groups[i].index;
        }
    }
    onModification() {
        this.isReduced = false;
        this.isOptimized = false;
    }
    reduce() {
        if (this.isReduced) {
            return;
        }
        for (const group of this.groups) {
            this.dfsRemoveRedundantEdges(group);
        }
        this.isReduced = true;
    }
    reduceAndOptimize() {
        if (this.isOptimized) {
            return;
        }
        this.reduce();
        for (const group of this.rootGroups.values()) {
            this.removeEmptyGroups(group);
        }
        for (const group of this.rootGroups.values()) {
            this.removeUselessGroups(group);
        }
        for (const group of this.rootGroups.values()) {
            this.mergeChildFetchesForSameSubgraphAndPath(group);
        }
        this.mergeFetchesToSameSubgraphAndSameInputs();
        this.isOptimized = true;
    }
    removeEmptyGroups(group) {
        const children = group.children().concat();
        if (group.selection.isEmpty() && !this.isRootGroup(group)) {
            this.remove(group);
        }
        for (const g of children) {
            this.removeEmptyGroups(g);
        }
    }
    removeUselessGroups(group) {
        for (const child of group.children()) {
            this.removeUselessGroups(child);
        }
        if (group.isUseless()) {
            if (group.children().length === 0) {
                this.remove(group);
            }
            else {
                const parents = group.parents();
                const parent = parents[0];
                if (parents.length === 1 && parent.path) {
                    parent.group.removeUselessChild(group);
                }
            }
        }
    }
    mergeChildFetchesForSameSubgraphAndPath(group) {
        const children = group.children();
        if (children.length > 1) {
            for (let i = 0; i < children.length; i++) {
                const gi = children[i];
                let j = i + 1;
                while (j < children.length) {
                    const gj = children[j];
                    if (gi.canMergeSiblingIn(gj)) {
                        gi.mergeSiblingIn(gj);
                        this.dfsRemoveRedundantEdges(gi);
                    }
                    else {
                        ++j;
                    }
                }
            }
        }
        for (const g of children) {
            this.mergeChildFetchesForSameSubgraphAndPath(g);
        }
    }
    mergeFetchesToSameSubgraphAndSameInputs() {
        const makeKey = (g) => { var _a, _b; return `${toValidGraphQLName(g.subgraphName)}-${(_b = (_a = g.mergeAt) === null || _a === void 0 ? void 0 : _a.join('::')) !== null && _b !== void 0 ? _b : ''}`; };
        const bySubgraphs = new federation_internals_1.MultiMap();
        for (const group of this.groups) {
            if (group.inputs) {
                bySubgraphs.add(makeKey(group), group);
            }
        }
        for (const groups of bySubgraphs.values()) {
            if (groups.length <= 1) {
                continue;
            }
            const toMergeBuckets = [];
            while (groups.length > 1) {
                const group = groups.pop();
                const bucket = [group];
                let i = 0;
                while (i < groups.length) {
                    const current = groups[i];
                    if (group.deferRef === current.deferRef && group.inputs.equals(current.inputs)) {
                        bucket.push(current);
                        groups.splice(i, 1);
                    }
                    else {
                        ++i;
                    }
                }
                if (bucket.length > 1) {
                    toMergeBuckets.push(bucket);
                }
            }
            for (const bucket of toMergeBuckets) {
                const group = bucket.pop();
                for (const other of bucket) {
                    group.mergeInWithAllDependencies(other);
                }
            }
        }
        this.reduce();
    }
    dfsRemoveRedundantEdges(from) {
        for (const startVertex of from.children()) {
            const stack = startVertex.children().concat();
            while (stack.length > 0) {
                const v = stack.pop();
                from.removeChild(v);
                stack.push(...v.children());
            }
        }
    }
    extractChildrenAndDeferredDependencies(group) {
        const children = [];
        const deferredGroups = new federation_internals_1.SetMultiMap();
        for (const child of group.children()) {
            if (group.deferRef === child.deferRef) {
                children.push(child);
            }
            else {
                (0, federation_internals_1.assert)(child.deferRef, () => `${group} has deferRef "${group.deferRef}", so its child ${child} cannot have a top-level deferRef`);
                if (!group.selection.isEmpty()) {
                    if (!group.id) {
                        group.id = String(this.fetchIdGen++);
                    }
                    this.deferTracking.addDependency(child.deferRef, group.id);
                }
                deferredGroups.add(child.deferRef, child);
            }
        }
        return { children, deferredGroups };
    }
    processGroup(processor, group) {
        const { children, deferredGroups } = this.extractChildrenAndDeferredDependencies(group);
        const processed = processor.onFetchGroup(group);
        if (children.length == 0) {
            return { main: processed, unhandled: [], deferredGroups };
        }
        const groupIsOnlyParentOfAllChildren = children.every(g => g.parents().length === 1);
        if (groupIsOnlyParentOfAllChildren) {
            const { mainSequence, unhandled, deferredGroups: allDeferredGroups, } = this.processRootMainGroups({
                processor,
                rootGroups: children,
                rootsAreParallel: true,
                initialDeferredGroups: deferredGroups,
            });
            return {
                main: processor.reduceSequence([processed].concat(mainSequence)),
                unhandled,
                deferredGroups: allDeferredGroups,
            };
        }
        else {
            return {
                main: processed,
                unhandled: children.map(g => [g, g.parents().filter((p) => p.group !== group)]),
                deferredGroups,
            };
        }
    }
    processGroups(processor, groups, processInParallel, remaining) {
        const processedNodes = [];
        const allDeferredGroups = new federation_internals_1.SetMultiMap();
        let remainingNext = remaining;
        let toHandleNext = [];
        for (const group of groups) {
            const { main, deferredGroups, unhandled } = this.processGroup(processor, group);
            processedNodes.push(main);
            allDeferredGroups.addAll(deferredGroups);
            const [canHandle, newRemaining] = this.mergeRemainings(remainingNext, unhandled);
            toHandleNext = toHandleNext.concat(canHandle);
            remainingNext = newRemaining;
        }
        return {
            processed: processInParallel ? processor.reduceParallel(processedNodes) : processor.reduceSequence(processedNodes),
            next: toHandleNext,
            unhandled: remainingNext,
            deferredGroups: allDeferredGroups,
        };
    }
    mergeRemainings(r1, r2) {
        const unhandled = [];
        const toHandle = [];
        for (const [g, edges] of r1) {
            const newEdges = this.mergeRemaingsAndRemoveIfFound(g, edges, r2);
            if (newEdges.length == 0) {
                toHandle.push(g);
            }
            else {
                unhandled.push([g, newEdges]);
            }
        }
        unhandled.push(...r2);
        return [toHandle, unhandled];
    }
    mergeRemaingsAndRemoveIfFound(group, inEdges, otherGroups) {
        const idx = otherGroups.findIndex(g => g[0] === group);
        if (idx < 0) {
            return inEdges;
        }
        else {
            const otherEdges = otherGroups[idx][1];
            otherGroups.splice(idx, 1);
            return inEdges.filter(e => otherEdges.includes(e));
        }
    }
    processRootMainGroups({ processor, rootGroups, rootsAreParallel, initialDeferredGroups, }) {
        let nextGroups = rootGroups;
        let remainingNext = [];
        const mainSequence = [];
        const allDeferredGroups = initialDeferredGroups
            ? new federation_internals_1.SetMultiMap(initialDeferredGroups)
            : new federation_internals_1.SetMultiMap();
        let processInParallel = rootsAreParallel;
        while (nextGroups.length > 0) {
            const { processed, next, unhandled, deferredGroups } = this.processGroups(processor, nextGroups, processInParallel, remainingNext);
            processInParallel = true;
            mainSequence.push(processed);
            const [canHandle, newRemaining] = this.mergeRemainings(remainingNext, unhandled);
            remainingNext = newRemaining;
            nextGroups = canHandle.concat(next);
            allDeferredGroups.addAll(deferredGroups);
        }
        return {
            mainSequence,
            unhandled: remainingNext,
            deferredGroups: allDeferredGroups,
        };
    }
    processRootGroups({ processor, rootGroups, rootsAreParallel = true, currentDeferRef, otherDeferGroups = undefined, }) {
        var _a;
        const { mainSequence, unhandled, deferredGroups, } = this.processRootMainGroups({ processor, rootsAreParallel, rootGroups });
        (0, federation_internals_1.assert)(unhandled.length == 0, () => `Root groups ${rootGroups} should have no remaining groups unhandled, but got ${unhandled}`);
        const allDeferredGroups = new federation_internals_1.SetMultiMap();
        if (otherDeferGroups) {
            allDeferredGroups.addAll(otherDeferGroups);
        }
        allDeferredGroups.addAll(deferredGroups);
        const defersInCurrent = this.deferTracking.defersInParent(currentDeferRef);
        const handledDefersInCurrent = new Set(defersInCurrent.map((d) => d.label));
        const unhandledDefersInCurrent = (0, federation_internals_1.mapKeys)(allDeferredGroups).filter((label) => !handledDefersInCurrent.has(label));
        let unhandledDeferGroups = undefined;
        if (unhandledDefersInCurrent.length > 0) {
            unhandledDeferGroups = new federation_internals_1.SetMultiMap();
            for (const label of unhandledDefersInCurrent) {
                unhandledDeferGroups.set(label, allDeferredGroups.get(label));
            }
        }
        const allDeferred = [];
        for (const defer of defersInCurrent) {
            const groups = (_a = allDeferredGroups.get(defer.label)) !== null && _a !== void 0 ? _a : [];
            const { mainSequence: mainSequenceOfDefer, deferred: deferredOfDefer } = this.processRootGroups({
                processor,
                rootGroups: Array.from(groups),
                rootsAreParallel: true,
                currentDeferRef: defer.label,
                otherDeferGroups: unhandledDeferGroups,
            });
            const mainReduced = processor.reduceSequence(mainSequenceOfDefer);
            const processed = deferredOfDefer.length === 0
                ? mainReduced
                : processor.reduceDefer(mainReduced, defer.subselection, deferredOfDefer);
            allDeferred.push(processor.reduceDeferred(defer, processed));
        }
        return { mainSequence, deferred: allDeferred };
    }
    process(processor, rootKind) {
        this.reduceAndOptimize();
        const { mainSequence, deferred } = this.processRootGroups({
            processor,
            rootGroups: this.rootGroups.values(),
            rootsAreParallel: rootKind === 'query',
        });
        return {
            main: processor.reduceSequence(mainSequence),
            deferred,
        };
    }
    dumpOnConsole(msg) {
        if (msg) {
            console.log(msg);
        }
        console.log('Groups:');
        for (const group of this.groups) {
            console.log(`  ${group}`);
        }
        console.log('Children relationships:');
        for (const group of this.groups) {
            const children = group.children();
            if (children.length === 1) {
                console.log(`  [${group.index}] => [ ${children[0]} ]`);
            }
            else if (children.length !== 0) {
                console.log(`  [${group.index}] => [\n    ${children.join('\n    ')}\n  ]`);
            }
        }
        console.log('Parent relationships:');
        const printParentRelation = (rel) => (rel.path ? `${rel.group} (path: [${rel.path.join(', ')}])` : rel.group.toString());
        for (const group of this.groups) {
            const parents = group.parents();
            if (parents.length === 1) {
                console.log(`  [${group.index}] => [ ${printParentRelation(parents[0])} ]`);
            }
            else if (parents.length !== 0) {
                console.log(`  [${group.index}] => [\n    ${parents.map(printParentRelation).join('\n    ')}\n  ]`);
            }
        }
        console.log('--------');
    }
    toString() {
        return this.rootGroups.values().map(g => this.toStringInternal(g, "")).join('\n');
    }
    toStringInternal(group, indent) {
        const children = group.children();
        return [indent + group.subgraphName + ' <- ' + children.map((child) => child.subgraphName).join(', ')]
            .concat(children
            .flatMap(g => g.children().length == 0
            ? []
            : this.toStringInternal(g, indent + "  ")))
            .join('\n');
    }
}
class QueryPlanner {
    constructor(supergraphSchema, config) {
        this.supergraphSchema = supergraphSchema;
        this.interfaceTypesWithInterfaceObjects = new Set();
        this.config = (0, config_1.enforceQueryPlannerConfigDefaults)(config);
        this.federatedQueryGraph = (0, query_graphs_1.buildFederatedQueryGraph)(supergraphSchema, true);
        this.collectInterfaceTypesWithInterfaceObjects();
    }
    collectInterfaceTypesWithInterfaceObjects() {
        const isInterfaceObject = (name, schema) => {
            const typeInSchema = schema.type(name);
            return !!typeInSchema && (0, federation_internals_1.isInterfaceObjectType)(typeInSchema);
        };
        for (const itfType of this.supergraphSchema.interfaceTypes()) {
            if ((0, federation_internals_1.mapValues)(this.federatedQueryGraph.sources).some((s) => isInterfaceObject(itfType.name, s))) {
                this.interfaceTypesWithInterfaceObjects.add(itfType.name);
            }
        }
    }
    buildQueryPlan(operation) {
        var _a;
        if (operation.selectionSet.isEmpty()) {
            return { kind: 'QueryPlan' };
        }
        if (operation.rootKind === 'subscription') {
            throw federation_internals_1.ERRORS.UNSUPPORTED_FEATURE.err('Query planning does not currently support subscriptions.', { nodes: [(0, graphql_1.parse)(operation.toString())] });
        }
        const statistics = {
            evaluatedPlanCount: 0,
        };
        this._lastGeneratedPlanStatistics = statistics;
        const reuseQueryFragments = (_a = this.config.reuseQueryFragments) !== null && _a !== void 0 ? _a : true;
        let fragments = operation.selectionSet.fragments;
        if (fragments && reuseQueryFragments) {
            fragments = addTypenameFieldForAbstractTypesInNamedFragments(fragments);
        }
        else {
            fragments = undefined;
        }
        operation = operation.expandAllFragments();
        operation = withoutIntrospection(operation);
        operation = this.withSiblingTypenameOptimizedAway(operation);
        let assignedDeferLabels = undefined;
        let hasDefers = false;
        let deferConditions = undefined;
        if (this.config.incrementalDelivery.enableDefer) {
            ({ operation, hasDefers, assignedDeferLabels, deferConditions } = operation.withNormalizedDefer());
        }
        else {
            operation = operation.withoutDefer();
        }
        debug.group(() => `Computing plan for\n${operation}`);
        if (operation.selectionSet.isEmpty()) {
            debug.groupEnd('Empty plan');
            return { kind: 'QueryPlan' };
        }
        const root = this.federatedQueryGraph.root(operation.rootKind);
        (0, federation_internals_1.assert)(root, () => `Shouldn't have a ${operation.rootKind} operation if the subgraphs don't have a ${operation.rootKind} root`);
        const processor = fetchGroupToPlanProcessor({
            config: this.config,
            variableDefinitions: operation.variableDefinitions,
            fragments,
            operationName: operation.name,
            assignedDeferLabels,
        });
        let rootNode;
        if (deferConditions && deferConditions.size > 0) {
            (0, federation_internals_1.assert)(hasDefers, 'Should not have defer conditions without @defer');
            rootNode = computePlanForDeferConditionals({
                supergraphSchema: this.supergraphSchema,
                federatedQueryGraph: this.federatedQueryGraph,
                operation,
                processor,
                root,
                deferConditions,
                statistics,
            });
        }
        else {
            rootNode = computePlanInternal({
                supergraphSchema: this.supergraphSchema,
                federatedQueryGraph: this.federatedQueryGraph,
                operation,
                processor,
                root,
                hasDefers,
                statistics,
            });
        }
        debug.groupEnd('Query plan computed');
        return { kind: 'QueryPlan', node: rootNode };
    }
    optimizeSiblingTypenames(selectionSet) {
        const selections = selectionSet.selections();
        const parentType = selectionSet.parentType;
        const parentMaybeInterfaceObject = this.interfaceTypesWithInterfaceObjects.has(parentType.name);
        let updatedSelections = undefined;
        let typenameSelection = undefined;
        let firstFieldSelection = undefined;
        for (let i = 0; i < selections.length; i++) {
            const selection = selections[i];
            let updated;
            if (!typenameSelection
                && selection.kind === 'FieldSelection'
                && selection.field.name === federation_internals_1.typenameFieldName
                && !parentMaybeInterfaceObject) {
                updated = undefined;
                typenameSelection = selection;
            }
            else {
                const updatedSubSelection = selection.selectionSet ? this.optimizeSiblingTypenames(selection.selectionSet) : undefined;
                if (updatedSubSelection === selection.selectionSet) {
                    updated = selection;
                }
                else {
                    updated = selection.withUpdatedSubSelection(updatedSubSelection);
                }
                if (!firstFieldSelection && updated.kind === 'FieldSelection') {
                    firstFieldSelection = updated;
                }
            }
            if (updated !== selection && !updatedSelections) {
                updatedSelections = [];
                for (let j = 0; j < i; j++) {
                    updatedSelections.push(selections[j]);
                }
            }
            if (updatedSelections && !!updated) {
                updatedSelections.push(updated);
            }
        }
        if (!updatedSelections || updatedSelections.length === 0) {
            return selectionSet;
        }
        if (typenameSelection) {
            if (firstFieldSelection) {
                firstFieldSelection.element().addAttachement(SIBLING_TYPENAME_KEY, typenameSelection.field.alias ? typenameSelection.field.alias : '');
            }
            else {
                updatedSelections = [typenameSelection].concat(updatedSelections);
            }
        }
        return new federation_internals_1.SelectionSet(selectionSet.parentType, selectionSet.fragments).addAll(updatedSelections);
    }
    withSiblingTypenameOptimizedAway(operation) {
        const updatedSelectionSet = this.optimizeSiblingTypenames(operation.selectionSet);
        if (updatedSelectionSet === operation.selectionSet) {
            return operation;
        }
        return new federation_internals_1.Operation(operation.schema, operation.rootKind, updatedSelectionSet, operation.variableDefinitions, operation.name);
    }
    lastGeneratedPlanStatistics() {
        return this._lastGeneratedPlanStatistics;
    }
}
exports.QueryPlanner = QueryPlanner;
function computePlanInternal({ supergraphSchema, federatedQueryGraph, operation, processor, root, hasDefers, statistics, }) {
    let main = undefined;
    let primarySelection = undefined;
    let deferred = [];
    if (operation.rootKind === 'mutation') {
        const dependencyGraphs = computeRootSerialDependencyGraph(supergraphSchema, operation, federatedQueryGraph, root, hasDefers, statistics);
        for (const dependencyGraph of dependencyGraphs) {
            const { main: localMain, deferred: localDeferred } = dependencyGraph.process(processor, operation.rootKind);
            main = main ? processor.reduceSequence([main, localMain]) : localMain;
            deferred = deferred.concat(localDeferred);
            const newSelection = dependencyGraph.deferTracking.primarySelection;
            if (newSelection) {
                if (primarySelection) {
                    primarySelection.mergeIn(newSelection);
                }
                else {
                    primarySelection = newSelection.clone();
                }
            }
        }
    }
    else {
        const dependencyGraph = computeRootParallelDependencyGraph(supergraphSchema, operation, federatedQueryGraph, root, 0, hasDefers, statistics);
        ({ main, deferred } = dependencyGraph.process(processor, operation.rootKind));
        primarySelection = dependencyGraph.deferTracking.primarySelection;
    }
    if (deferred.length > 0) {
        (0, federation_internals_1.assert)(primarySelection, 'Should have had a primary selection created');
        return processor.reduceDefer(main, primarySelection, deferred);
    }
    return main;
}
function computePlanForDeferConditionals({ supergraphSchema, federatedQueryGraph, operation, processor, root, deferConditions, statistics, }) {
    return generateConditionNodes(operation, Array.from(deferConditions.entries()), 0, (op) => computePlanInternal({
        supergraphSchema,
        federatedQueryGraph,
        operation: op,
        processor,
        root,
        hasDefers: true,
        statistics,
    }));
}
function generateConditionNodes(operation, conditions, idx, onFinalOperation) {
    if (idx >= conditions.length) {
        return onFinalOperation(operation);
    }
    const [variable, labels] = conditions[idx];
    const ifOperation = operation;
    const elseOperation = operation.withoutDefer(labels);
    return {
        kind: 'Condition',
        condition: variable,
        ifClause: generateConditionNodes(ifOperation, conditions, idx + 1, onFinalOperation),
        elseClause: generateConditionNodes(elseOperation, conditions, idx + 1, onFinalOperation),
    };
}
function isIntrospectionSelection(selection) {
    return selection.kind == 'FieldSelection' && selection.element().definition.isIntrospectionField();
}
function mapOptionsToSelections(selectionSet, options) {
    return selectionSet.selections(true).map(node => [node, options]);
}
function possiblePlans(closedBranches) {
    let totalCombinations = 1;
    for (let i = 0; i < closedBranches.length; ++i) {
        const eltSize = closedBranches[i].length;
        if (eltSize === 0) {
            return 0;
        }
        totalCombinations *= eltSize;
    }
    return totalCombinations;
}
function sum(arr) {
    return arr.reduce((a, b) => a + b, 0);
}
function selectionCost(selection, depth = 1) {
    return selection ? selection.selections().reduce((prev, curr) => prev + depth + selectionCost(curr.selectionSet, depth + 1), 0) : 0;
}
function withoutIntrospection(operation) {
    if (!operation.selectionSet.selections().some(isIntrospectionSelection)) {
        return operation;
    }
    const newSelections = operation.selectionSet.selections().filter(s => !isIntrospectionSelection(s));
    return new federation_internals_1.Operation(operation.schema, operation.rootKind, new federation_internals_1.SelectionSet(operation.selectionSet.parentType).addAll(newSelections), operation.variableDefinitions, operation.name);
}
function computeRootParallelDependencyGraph(supergraphSchema, operation, federatedQueryGraph, root, startFetchIdGen, hasDefer, statistics) {
    return computeRootParallelBestPlan(supergraphSchema, operation.selectionSet, operation.variableDefinitions, federatedQueryGraph, root, startFetchIdGen, hasDefer, statistics)[0];
}
function computeRootParallelBestPlan(supergraphSchema, selection, variables, federatedQueryGraph, root, startFetchIdGen, hasDefers, statistics) {
    const planningTraversal = new QueryPlanningTaversal(supergraphSchema, federatedQueryGraph, selection, startFetchIdGen, hasDefers, variables, statistics, root, root.rootKind, defaultCostFunction, query_graphs_1.emptyContext);
    const plan = planningTraversal.findBestPlan();
    return plan !== null && plan !== void 0 ? plan : createEmptyPlan(supergraphSchema, federatedQueryGraph, root);
}
function createEmptyPlan(supergraphSchema, federatedQueryGraph, root) {
    return [
        FetchDependencyGraph.create(supergraphSchema, federatedQueryGraph, 0, undefined),
        query_graphs_1.PathTree.createOp(federatedQueryGraph, root),
        0
    ];
}
function onlyRootSubgraph(graph) {
    const subgraphs = graph.rootSubgraphs();
    (0, federation_internals_1.assert)(subgraphs.length === 1, () => `${graph} should have only one root, but has [${graph.rootSubgraphs()}]`);
    return subgraphs[0];
}
function computeRootSerialDependencyGraph(supergraphSchema, operation, federatedQueryGraph, root, hasDefers, statistics) {
    const rootType = hasDefers ? supergraphSchema.schemaDefinition.rootType(root.rootKind) : undefined;
    const splittedRoots = splitTopLevelFields(operation.selectionSet);
    const graphs = [];
    let startingFetchId = 0;
    let [prevDepGraph, prevPaths] = computeRootParallelBestPlan(supergraphSchema, splittedRoots[0], operation.variableDefinitions, federatedQueryGraph, root, startingFetchId, hasDefers, statistics);
    let prevSubgraph = onlyRootSubgraph(prevDepGraph);
    for (let i = 1; i < splittedRoots.length; i++) {
        const [newDepGraph, newPaths] = computeRootParallelBestPlan(supergraphSchema, splittedRoots[i], operation.variableDefinitions, federatedQueryGraph, root, prevDepGraph.nextFetchId(), hasDefers, statistics);
        const newSubgraph = onlyRootSubgraph(newDepGraph);
        if (prevSubgraph === newSubgraph) {
            prevPaths = prevPaths.concat(newPaths);
            prevDepGraph = computeRootFetchGroups(FetchDependencyGraph.create(supergraphSchema, federatedQueryGraph, startingFetchId, rootType), prevPaths, root.rootKind);
        }
        else {
            startingFetchId = prevDepGraph.nextFetchId();
            graphs.push(prevDepGraph);
            [prevDepGraph, prevPaths, prevSubgraph] = [newDepGraph, newPaths, newSubgraph];
        }
    }
    graphs.push(prevDepGraph);
    return graphs;
}
function splitTopLevelFields(selectionSet) {
    return selectionSet.selections().flatMap(selection => {
        if (selection.kind === 'FieldSelection') {
            return [(0, federation_internals_1.selectionSetOf)(selectionSet.parentType, selection)];
        }
        else {
            return splitTopLevelFields(selection.selectionSet).map(s => (0, federation_internals_1.selectionSetOfElement)(selection.element(), s));
        }
    });
}
function toValidGraphQLName(subgraphName) {
    const sanitized = subgraphName
        .replace(/-/ig, '_')
        .replace(/[^_0-9A-Za-z]/ig, '');
    return sanitized.match(/^[0-9].*/i) ? '_' + sanitized : sanitized;
}
function sanitizeAndPrintSubselection(subSelection) {
    var _a;
    return (_a = subSelection.withoutEmptyBranches()) === null || _a === void 0 ? void 0 : _a.toString();
}
function fetchGroupToPlanProcessor({ config, variableDefinitions, fragments, operationName, assignedDeferLabels, }) {
    let counter = 0;
    return {
        onFetchGroup: (group) => group.toPlanNode(config, variableDefinitions, fragments, operationName ? `${operationName}__${toValidGraphQLName(group.subgraphName)}__${counter++}` : undefined),
        reduceParallel: (values) => flatWrapNodes('Parallel', values),
        reduceSequence: (values) => flatWrapNodes('Sequence', values),
        reduceDeferred: (deferInfo, value) => ({
            depends: [...deferInfo.dependencies].map((id) => ({ id })),
            label: (assignedDeferLabels === null || assignedDeferLabels === void 0 ? void 0 : assignedDeferLabels.has(deferInfo.label)) ? undefined : deferInfo.label,
            queryPath: (0, federation_internals_1.operationPathToStringPath)(deferInfo.path.full()),
            subselection: deferInfo.deferred.size === 0 ? sanitizeAndPrintSubselection(deferInfo.subselection) : undefined,
            node: value,
        }),
        reduceDefer: (main, subselection, deferredBlocks) => ({
            kind: 'Defer',
            primary: {
                subselection: sanitizeAndPrintSubselection(subselection),
                node: main,
            },
            deferred: deferredBlocks,
        }),
    };
}
function flatWrapNodes(kind, nodes) {
    const filteredNodes = nodes.filter((n) => !!n);
    if (filteredNodes.length === 0) {
        return undefined;
    }
    if (filteredNodes.length === 1) {
        return filteredNodes[0];
    }
    return {
        kind,
        nodes: filteredNodes.flatMap((n) => n.kind === kind ? n.nodes : [n]),
    };
}
function addTypenameFieldForAbstractTypesInNamedFragments(fragments) {
    const fragmentsMap = new Map();
    for (const fragment of fragments.definitions()) {
        const expandedSelectionSet = fragment.selectionSet.expandFragments();
        addTypenameFieldForAbstractTypes(expandedSelectionSet);
        const otherFragmentsUsages = new Map();
        fragment.collectUsedFragmentNames(otherFragmentsUsages);
        fragmentsMap.set(fragment.name, {
            original: fragment,
            expandedSelectionSet,
            dependentsOn: Array.from(otherFragmentsUsages.keys()),
        });
    }
    const optimizedFragments = new federation_internals_1.NamedFragments();
    while (fragmentsMap.size > 0) {
        for (const [name, info] of fragmentsMap) {
            if (info.dependentsOn.every((n) => optimizedFragments.has(n))) {
                const reoptimizedSelectionSet = info.expandedSelectionSet.optimize(optimizedFragments);
                optimizedFragments.add(info.original.withUpdatedSelectionSet(reoptimizedSelectionSet));
                fragmentsMap.delete(name);
            }
        }
    }
    return optimizedFragments;
}
function addSelectionOrSelectionSet(selectionSet, toAdd) {
    if (toAdd instanceof federation_internals_1.SelectionSet) {
        selectionSet.mergeIn(toAdd);
    }
    else {
        selectionSet.add(toAdd);
    }
}
function removeRedundantFragmentsOfSet(selectionSet, type, unneededDirectives) {
    let newSet = undefined;
    const selections = selectionSet.selections();
    for (let i = 0; i < selections.length; i++) {
        const selection = selections[i];
        const updated = removeRedundantFragments(selection, type, unneededDirectives);
        if (newSet) {
            addSelectionOrSelectionSet(newSet, updated);
        }
        else if (selection !== updated) {
            newSet = new federation_internals_1.SelectionSet(type);
            for (let j = 0; j < i; j++) {
                newSet.add(selections[j]);
            }
            addSelectionOrSelectionSet(newSet, updated);
        }
    }
    return newSet ? newSet : selectionSet;
}
function removeRedundantFragments(selection, type, unneededDirectives) {
    if (selection.kind !== 'FragmentSelection') {
        return selection;
    }
    const fragment = selection.element();
    const fragmentType = fragment.typeCondition;
    if (!fragmentType) {
        return selection;
    }
    let neededDirectives = [];
    if (fragment.appliedDirectives.length > 0) {
        neededDirectives = (0, federation_internals_1.directiveApplicationsSubstraction)(fragment.appliedDirectives, unneededDirectives);
    }
    if ((0, federation_internals_1.sameType)(type, fragmentType) && neededDirectives.length === 0) {
        return removeRedundantFragmentsOfSet(selection.selectionSet, type, unneededDirectives);
    }
    else if (neededDirectives.length === fragment.appliedDirectives.length) {
        return selection;
    }
    else {
        const updatedFragment = new federation_internals_1.FragmentElement(type, fragment.typeCondition);
        neededDirectives.forEach((d) => updatedFragment.applyDirective(d.definition, d.arguments()));
        return (0, federation_internals_1.selectionSetOfElement)(updatedFragment, selection.selectionSet);
    }
}
function schemaRootKindToOperationKind(operation) {
    switch (operation) {
        case "query": return graphql_1.OperationTypeNode.QUERY;
        case "mutation": return graphql_1.OperationTypeNode.MUTATION;
        case "subscription": return graphql_1.OperationTypeNode.SUBSCRIPTION;
    }
}
function findAndRemoveInPlace(predicate, array) {
    const idx = array.findIndex((v) => predicate(v));
    if (idx >= 0) {
        array.splice(idx, 1);
    }
    return idx;
}
function sameMergeAt(m1, m2) {
    if (!m1) {
        return !m2;
    }
    if (!m2) {
        return false;
    }
    return (0, federation_internals_1.arrayEquals)(m1, m2);
}
function concatPathsInParents(first, second) {
    return first && second ? (0, federation_internals_1.concatOperationPaths)(first, second) : undefined;
}
function samePathsInParents(first, second) {
    if (!first) {
        return !second;
    }
    return !!second && (0, federation_internals_1.sameOperationPaths)(first, second);
}
function computeRootFetchGroups(dependencyGraph, pathTree, rootKind) {
    for (const [edge, _trigger, _conditions, child] of pathTree.childElements()) {
        (0, federation_internals_1.assert)(edge !== null, `The root edge should not be null`);
        const subgraphName = edge.tail.source;
        const rootType = edge.tail.type;
        const group = dependencyGraph.getOrCreateRootFetchGroup({ subgraphName, rootKind, parentType: rootType });
        computeGroupsForTree(dependencyGraph, child, group, GroupPath.empty(), emptyDeferContext);
    }
    return dependencyGraph;
}
function computeNonRootFetchGroups(dependencyGraph, pathTree, rootKind) {
    const subgraphName = pathTree.vertex.source;
    const rootType = pathTree.vertex.type;
    (0, federation_internals_1.assert)((0, federation_internals_1.isCompositeType)(rootType), () => `Should not have condition on non-selectable type ${rootType}`);
    const group = dependencyGraph.getOrCreateRootFetchGroup({ subgraphName, rootKind, parentType: rootType });
    computeGroupsForTree(dependencyGraph, pathTree, group, GroupPath.empty(), emptyDeferContext);
    return dependencyGraph;
}
function wrapInputsSelections(wrappingType, selections, context) {
    return wrapSelectionWithTypeAndConditions(wrappingType, selections, (fragment, currentSeletions) => (0, federation_internals_1.selectionSetOf)(fragment.parentType, (0, federation_internals_1.selectionOfElement)(fragment, currentSeletions)), context);
}
function createFetchInitialPath(wrappingType, context) {
    return wrapSelectionWithTypeAndConditions(wrappingType, [], (fragment, path) => [fragment].concat(path), context);
}
function wrapSelectionWithTypeAndConditions(wrappingType, initialSelection, wrapInFragment, context) {
    const typeCast = new federation_internals_1.FragmentElement(wrappingType, wrappingType.name);
    let updatedSelection = wrapInFragment(typeCast, initialSelection);
    if (context.conditionals.length === 0) {
        return updatedSelection;
    }
    const schema = wrappingType.schema();
    const [name0, ifs0] = context.conditionals[0];
    typeCast.applyDirective(schema.directive(name0), { 'if': ifs0 });
    for (let i = 1; i < context.conditionals.length; i++) {
        const [name, ifs] = context.conditionals[i];
        const fragment = new federation_internals_1.FragmentElement(wrappingType, wrappingType.name);
        fragment.applyDirective(schema.directive(name), { 'if': ifs });
        updatedSelection = wrapInFragment(fragment, updatedSelection);
    }
    return updatedSelection;
}
function extractPathInParentForKeyFetch(type, path) {
    var _a;
    const inGroup = path.inGroup();
    const lastElement = inGroup[inGroup.length - 1];
    return (lastElement && lastElement.kind === 'FragmentElement' && ((_a = lastElement.typeCondition) === null || _a === void 0 ? void 0 : _a.name) === type.name)
        ? inGroup.slice(0, inGroup.length - 1)
        : inGroup;
}
function maybeSubstratPathPrefix(basePath, maybePrefix) {
    if (maybePrefix.length <= basePath.length && (0, federation_internals_1.sameOperationPaths)(maybePrefix, basePath.slice(0, maybePrefix.length))) {
        return basePath.slice(maybePrefix.length);
    }
    return undefined;
}
function computeGroupsForTree(dependencyGraph, pathTree, startGroup, initialGroupPath, initialDeferContext, initialContext = query_graphs_1.emptyContext) {
    const stack = [{
            tree: pathTree,
            group: startGroup,
            path: initialGroupPath,
            context: initialContext,
            deferContext: initialDeferContext,
        }];
    const createdGroups = [];
    while (stack.length > 0) {
        const { tree, group, path, context, deferContext } = stack.pop();
        if (tree.isLeaf()) {
            group.addSelection(path.inGroup());
            dependencyGraph.deferTracking.updateSubselection(deferContext);
        }
        else {
            for (const [edge, operation, conditions, child] of tree.childElements(true)) {
                if ((0, query_graphs_1.isPathContext)(operation)) {
                    const newContext = operation;
                    (0, federation_internals_1.assert)(edge !== null, () => `Unexpected 'null' edge with no trigger at ${path}`);
                    if (edge.transition.kind === 'KeyResolution') {
                        (0, federation_internals_1.assert)(conditions, () => `Key edge ${edge} should have some conditions paths`);
                        const conditionsGroups = computeGroupsForTree(dependencyGraph, conditions, group, path, deferContextForConditions(deferContext));
                        createdGroups.push(...conditionsGroups);
                        const sourceType = edge.head.type;
                        const destType = edge.tail.type;
                        const pathInParent = extractPathInParentForKeyFetch(sourceType, path);
                        const updatedDeferContext = deferContextAfterSubgraphJump(deferContext);
                        const newGroup = dependencyGraph.getOrCreateKeyFetchGroup({
                            subgraphName: edge.tail.source,
                            mergeAt: path.inResponse(),
                            inputsTypeName: destType.name,
                            type: destType,
                            parent: { group, path: pathInParent },
                            conditionsGroups,
                            deferRef: updatedDeferContext.activeDeferRef,
                        });
                        createdGroups.push(newGroup);
                        newGroup.addParents(conditionsGroups.map((conditionGroup) => {
                            const conditionGroupParents = conditionGroup.parents();
                            let path = undefined;
                            if (conditionGroupParents.length === 1 && conditionGroupParents[0].group === group && conditionGroupParents[0].path) {
                                path = maybeSubstratPathPrefix(conditionGroupParents[0].path, pathInParent);
                            }
                            return { group: conditionGroup, path };
                        }));
                        const inputType = dependencyGraph.typeForFetchInputs(sourceType.name);
                        const inputSelections = newCompositeTypeSelectionSet(inputType);
                        inputSelections.mergeIn(edge.conditions);
                        newGroup.addInputs(wrapInputsSelections(inputType, inputSelections, newContext), computeInputRewritesOnKeyFetch(inputType.name, destType));
                        group.addSelection(path.inGroup().concat(new federation_internals_1.Field(sourceType.typenameField())));
                        stack.push({
                            tree: child,
                            group: newGroup,
                            path: path.forNewKeyFetch(createFetchInitialPath(edge.tail.type, newContext)),
                            context: newContext,
                            deferContext: updatedDeferContext,
                        });
                    }
                    else {
                        (0, federation_internals_1.assert)(edge.transition.kind === 'RootTypeResolution', () => `Unexpected non-collecting edge ${edge}`);
                        const rootKind = edge.transition.rootKind;
                        (0, federation_internals_1.assert)(!conditions, () => `Root type resolution edge ${edge} should not have conditions`);
                        (0, federation_internals_1.assert)((0, federation_internals_1.isObjectType)(edge.head.type) && (0, federation_internals_1.isObjectType)(edge.tail.type), () => `Expected an objects for the vertices of ${edge}`);
                        const type = edge.tail.type;
                        (0, federation_internals_1.assert)(type === type.schema().schemaDefinition.rootType(rootKind), () => `Expected ${type} to be the root ${rootKind} type, but that is ${type.schema().schemaDefinition.rootType(rootKind)}`);
                        if (path.inGroup().length > 0) {
                            group.addSelection(path.inGroup().concat(new federation_internals_1.Field(edge.head.type.typenameField())));
                        }
                        const updatedDeferContext = deferContextAfterSubgraphJump(deferContext);
                        const newGroup = dependencyGraph.newRootTypeFetchGroup({
                            subgraphName: edge.tail.source,
                            rootKind,
                            parentType: type,
                            mergeAt: path.inResponse(),
                            deferRef: updatedDeferContext.activeDeferRef,
                        });
                        newGroup.addParent({ group, path: path.inGroup() });
                        stack.push({
                            tree: child,
                            group: newGroup,
                            path: path.forNewKeyFetch(createFetchInitialPath(type, newContext)),
                            context: newContext,
                            deferContext: updatedDeferContext,
                        });
                    }
                }
                else if (edge === null) {
                    const { updatedOperation, updatedDeferContext } = extractDeferFromOperation({
                        dependencyGraph,
                        operation,
                        deferContext,
                        path,
                    });
                    let newPath = path;
                    if (updatedOperation && updatedOperation.appliedDirectives.length > 0) {
                        newPath = path.add(updatedOperation);
                    }
                    stack.push({
                        tree: child,
                        group,
                        path: newPath,
                        context,
                        deferContext: updatedDeferContext,
                    });
                }
                else {
                    (0, federation_internals_1.assert)(edge.head.source === edge.tail.source, () => `Collecting edge ${edge} for ${operation} should not change the underlying subgraph`);
                    const typenameAttachment = operation.getAttachement(SIBLING_TYPENAME_KEY);
                    if (typenameAttachment !== undefined) {
                        const alias = typenameAttachment === '' ? undefined : typenameAttachment;
                        const typenameField = new federation_internals_1.Field(operation.parentType.typenameField(), {}, new federation_internals_1.VariableDefinitions(), alias);
                        group.addSelection(path.inGroup().concat(typenameField));
                        dependencyGraph.deferTracking.updateSubselection({
                            ...deferContext,
                            pathToDeferParent: deferContext.pathToDeferParent.concat(typenameField),
                        });
                    }
                    const { updatedOperation, updatedDeferContext } = extractDeferFromOperation({
                        dependencyGraph,
                        operation,
                        deferContext,
                        path,
                    });
                    (0, federation_internals_1.assert)(updatedOperation, `Extracting @defer from ${operation} should not have resulted in no operation`);
                    let updated = {
                        tree: child,
                        group,
                        path,
                        context,
                        deferContext: updatedDeferContext
                    };
                    if (conditions) {
                        const requireResult = handleRequires(dependencyGraph, edge, conditions, group, path, context, updatedDeferContext);
                        updated.group = requireResult.group;
                        updated.path = requireResult.path;
                        createdGroups.push(...requireResult.createdGroups);
                    }
                    if (updatedOperation.kind === 'Field' && updatedOperation.name === federation_internals_1.typenameFieldName) {
                        updated.group.mustPreserveSelection = true;
                    }
                    if (edge.transition.kind === 'InterfaceObjectFakeDownCast') {
                        (0, federation_internals_1.assert)(updatedOperation.kind === 'FragmentElement', () => `Unexpected operation ${updatedOperation} for edge ${edge}`);
                        if (updatedOperation.appliedDirectives.length > 0) {
                            updated.path = updated.path.add(updatedOperation.withUpdatedCondition(undefined));
                        }
                    }
                    else {
                        updated.path = updated.path.add(updatedOperation);
                    }
                    stack.push(updated);
                }
            }
        }
    }
    return createdGroups;
}
function computeInputRewritesOnKeyFetch(inputTypeName, destType) {
    if ((0, federation_internals_1.isInterfaceObjectType)(destType)) {
        return [{
                kind: 'ValueSetter',
                path: [`... on ${inputTypeName}`, federation_internals_1.typenameFieldName],
                setValueTo: destType.name,
            }];
    }
    return undefined;
}
function extractDeferFromOperation({ dependencyGraph, operation, deferContext, path, }) {
    const deferArgs = operation.deferDirectiveArgs();
    if (!deferArgs) {
        return {
            updatedOperation: operation,
            updatedDeferContext: {
                ...deferContext,
                pathToDeferParent: deferContext.pathToDeferParent.concat(operation),
            }
        };
    }
    (0, federation_internals_1.assert)(deferArgs.label, 'All defers should have a lalel at this point');
    const updatedDeferRef = deferArgs.label;
    const updatedOperation = operation.withoutDefer();
    const updatedPathToDeferParent = updatedOperation ? [updatedOperation] : [];
    dependencyGraph.deferTracking.registerDefer({
        deferContext,
        deferArgs,
        path,
        parentType: operation.parentType,
    });
    return {
        updatedOperation,
        updatedDeferContext: {
            ...deferContext,
            currentDeferRef: updatedDeferRef,
            pathToDeferParent: updatedPathToDeferParent,
        },
    };
}
function addTypenameFieldForAbstractTypes(selectionSet) {
    for (const selection of selectionSet.selections()) {
        if (selection.kind == 'FieldSelection') {
            const fieldBaseType = (0, federation_internals_1.baseType)(selection.field.definition.type);
            if ((0, federation_internals_1.isAbstractType)(fieldBaseType)) {
                selection.selectionSet.add(new federation_internals_1.FieldSelection(new federation_internals_1.Field(fieldBaseType.typenameField())));
            }
            if (selection.selectionSet) {
                addTypenameFieldForAbstractTypes(selection.selectionSet);
            }
        }
        else {
            const conditionType = selection.element().typeCondition;
            if (conditionType && (0, federation_internals_1.isAbstractType)(conditionType)) {
                selection.selectionSet.add(new federation_internals_1.FieldSelection(new federation_internals_1.Field(conditionType.typenameField())));
            }
            addTypenameFieldForAbstractTypes(selection.selectionSet);
        }
    }
}
function pathHasOnlyFragments(path) {
    return path.every((element) => element.kind === 'FragmentElement');
}
function typeAtPath(parentType, path) {
    var _a;
    let type = parentType;
    for (const element of path) {
        if (element.kind === 'Field') {
            const fieldType = (0, federation_internals_1.baseType)((_a = type.field(element.name)) === null || _a === void 0 ? void 0 : _a.type);
            (0, federation_internals_1.assert)((0, federation_internals_1.isCompositeType)(fieldType), () => `Invalid call fro ${path} starting at ${parentType}: ${element.definition.coordinate} is not composite`);
            type = fieldType;
        }
        else if (element.typeCondition) {
            const rebasedType = parentType.schema().type(element.typeCondition.name);
            (0, federation_internals_1.assert)(rebasedType && (0, federation_internals_1.isCompositeType)(rebasedType), () => `Type condition of ${element} should be composite`);
            type = rebasedType;
        }
    }
    return type;
}
function handleRequires(dependencyGraph, edge, requiresConditions, group, path, context, deferContext) {
    const entityType = edge.head.type;
    dependencyGraph.reduce();
    const parents = group.parents();
    if (parents.length === 1 && pathHasOnlyFragments(path.inGroup())) {
        const parent = parents[0];
        const newGroup = dependencyGraph.newKeyFetchGroup({
            subgraphName: group.subgraphName,
            inputsTypeName: group.inputs.parentType.name,
            mergeAt: group.mergeAt,
            deferRef: group.deferRef
        });
        newGroup.addParent(parent);
        newGroup.copyInputsOf(group, true);
        const createdGroups = computeGroupsForTree(dependencyGraph, requiresConditions, newGroup, path, deferContextForConditions(deferContext));
        if (createdGroups.length == 0) {
            (0, federation_internals_1.assert)(group.canMergeSiblingIn(newGroup), () => `We should be able to merge ${newGroup} into ${group} by construction`);
            group.mergeSiblingIn(newGroup);
            return { group, path, createdGroups: [] };
        }
        newGroup.removeInputsFromSelection();
        let newGroupIsUnneeded = parent.path && newGroup.selection.canRebaseOn(typeAtPath(parent.group.selection.parentType, parent.path));
        const unmergedGroups = [];
        if (newGroupIsUnneeded) {
            parent.group.mergeChildIn(newGroup);
            for (const created of createdGroups) {
                if (created.subgraphName === parent.group.subgraphName && parent.group.canMergeChildIn(created)) {
                    parent.group.mergeChildIn(created);
                }
                else {
                    unmergedGroups.push(created);
                    let currentParent = parent;
                    while (currentParent
                        && !currentParent.group.isTopLevel
                        && created.isChildOfWithArtificialDependency(currentParent.group)) {
                        currentParent.group.removeChild(created);
                        const grandParents = currentParent.group.parents();
                        (0, federation_internals_1.assert)(grandParents.length > 0, `${currentParent.group} is not top-level, so it should have parents`);
                        for (const grandParent of grandParents) {
                            created.addParent({
                                group: grandParent.group,
                                path: concatPathsInParents(grandParent.path, currentParent.path),
                            });
                        }
                        currentParent = grandParents.length === 1 ? grandParents[0] : undefined;
                    }
                }
            }
        }
        else {
            (0, federation_internals_1.assert)(group.canMergeSiblingIn(newGroup), () => `We should be able to merge ${newGroup} into ${group} by construction`);
            group.mergeSiblingIn(newGroup);
            if (parent.path) {
                for (const created of createdGroups) {
                    if (created.subgraphName === parent.group.subgraphName
                        && parent.group.canMergeGrandChildIn(created)
                        && sameMergeAt(created.mergeAt, group.mergeAt)
                        && group.inputs.contains(created.inputs)) {
                        parent.group.mergeGrandChildIn(created);
                    }
                    else {
                        unmergedGroups.push(created);
                    }
                }
            }
        }
        if (unmergedGroups.length == 0) {
            group.addInputs(inputsForRequire(dependencyGraph, entityType, edge, context, false).inputs);
            return { group, path, createdGroups: [] };
        }
        const postRequireGroup = dependencyGraph.newKeyFetchGroup({
            subgraphName: group.subgraphName,
            inputsTypeName: entityType.name,
            mergeAt: group.mergeAt,
            deferRef: group.deferRef
        });
        postRequireGroup.addParents(unmergedGroups.map((group) => ({ group })));
        if (newGroupIsUnneeded) {
            postRequireGroup.addParent(parent);
        }
        else {
            postRequireGroup.addParent({ group, path: [] });
        }
        (0, federation_internals_1.assert)(parent.path, `Missing path-in-parent for @require on ${edge} with group ${group} and parent ${parent}`);
        addPostRequireInputs(dependencyGraph, path.forParentOfGroup(parent.path), entityType, edge, context, parent.group, postRequireGroup);
        return {
            group: postRequireGroup,
            path: path.forNewKeyFetch(createFetchInitialPath(entityType, context)),
            createdGroups: unmergedGroups.concat(postRequireGroup),
        };
    }
    else {
        const createdGroups = computeGroupsForTree(dependencyGraph, requiresConditions, group, path, deferContextForConditions(deferContext));
        if (createdGroups.length == 0) {
            return { group, path, createdGroups: [] };
        }
        const newGroup = dependencyGraph.newKeyFetchGroup({
            subgraphName: group.subgraphName,
            inputsTypeName: entityType.name,
            mergeAt: path.inResponse(),
        });
        newGroup.addParents(createdGroups.map((group) => ({ group })));
        addPostRequireInputs(dependencyGraph, path, entityType, edge, context, group, newGroup);
        return {
            group: newGroup,
            path: path.forNewKeyFetch(createFetchInitialPath(entityType, context)),
            createdGroups: createdGroups.concat(newGroup),
        };
    }
}
function addPostRequireInputs(dependencyGraph, requirePath, entityType, edge, context, preRequireGroup, postRequireGroup) {
    const { inputs, keyInputs } = inputsForRequire(dependencyGraph, entityType, edge, context);
    let rewrites = undefined;
    if (edge.transition.kind === 'InterfaceObjectFakeDownCast') {
        rewrites = computeInputRewritesOnKeyFetch(edge.transition.castedTypeName, entityType);
    }
    postRequireGroup.addInputs(inputs, rewrites);
    if (keyInputs) {
        preRequireGroup.addSelection(requirePath.inGroup(), (endOfPathSet) => {
            (0, federation_internals_1.assert)(endOfPathSet, () => `Merge path ${requirePath} ends on a non-selectable type`);
            endOfPathSet.addAll(keyInputs.selections());
        });
    }
}
function newCompositeTypeSelectionSet(type) {
    const selectionSet = new federation_internals_1.SelectionSet(type);
    selectionSet.add(new federation_internals_1.FieldSelection(new federation_internals_1.Field(type.typenameField())));
    return selectionSet;
}
function inputsForRequire(dependencyGraph, entityType, edge, context, includeKeyInputs = true) {
    const isInterfaceObjectDownCast = edge.transition.kind === 'InterfaceObjectFakeDownCast';
    const inputTypeName = isInterfaceObjectDownCast ? edge.transition.castedTypeName : entityType.name;
    const inputType = dependencyGraph.supergraphSchema.type(inputTypeName);
    (0, federation_internals_1.assert)(inputType && (0, federation_internals_1.isCompositeType)(inputType), () => `Type ${inputTypeName} should exist in the supergraph and be a composite type`);
    const fullSelectionSet = newCompositeTypeSelectionSet(inputType);
    fullSelectionSet.mergeIn(edge.conditions);
    let keyInputs = undefined;
    if (includeKeyInputs) {
        const keyCondition = (0, query_graphs_1.getLocallySatisfiableKey)(dependencyGraph.federatedQueryGraph, edge.head);
        (0, federation_internals_1.assert)(keyCondition, () => `Due to @require, validation should have required a key to be present for ${edge}`);
        let keyConditionAsInput = keyCondition;
        if (isInterfaceObjectDownCast) {
            const supergraphItfType = dependencyGraph.supergraphSchema.type(entityType.name);
            (0, federation_internals_1.assert)(supergraphItfType && (0, federation_internals_1.isInterfaceType)(supergraphItfType), () => `Type ${entityType} should be an interface in the supergraph`);
            const rebasedKeyCondition = new federation_internals_1.SelectionSet(supergraphItfType);
            rebasedKeyCondition.mergeIn(keyConditionAsInput);
            keyConditionAsInput = rebasedKeyCondition;
        }
        fullSelectionSet.mergeIn(keyConditionAsInput);
        keyInputs = newCompositeTypeSelectionSet(entityType);
        keyInputs.mergeIn(keyCondition);
    }
    return {
        inputs: wrapInputsSelections(inputType, fullSelectionSet, context),
        keyInputs,
    };
}
const representationsVariable = new federation_internals_1.Variable('representations');
function representationsVariableDefinition(schema) {
    const metadata = (0, federation_internals_1.federationMetadata)(schema);
    (0, federation_internals_1.assert)(metadata, 'Expected schema to be a federation subgraph');
    const representationsType = new federation_internals_1.NonNullType(new federation_internals_1.ListType(new federation_internals_1.NonNullType(metadata.anyType())));
    return new federation_internals_1.VariableDefinition(schema, representationsVariable, representationsType);
}
function operationForEntitiesFetch(subgraphSchema, selectionSet, allVariableDefinitions, operationName) {
    const variableDefinitions = new federation_internals_1.VariableDefinitions();
    variableDefinitions.add(representationsVariableDefinition(subgraphSchema));
    variableDefinitions.addAll(allVariableDefinitions.filter(selectionSet.usedVariables()));
    const queryType = subgraphSchema.schemaDefinition.rootType('query');
    (0, federation_internals_1.assert)(queryType, `Subgraphs should always have a query root (they should at least provides _entities)`);
    const entities = queryType.field(federation_internals_1.entitiesFieldName);
    (0, federation_internals_1.assert)(entities, `Subgraphs should always have the _entities field`);
    const entitiesCall = new federation_internals_1.SelectionSet(queryType);
    entitiesCall.add(new federation_internals_1.FieldSelection(new federation_internals_1.Field(entities, { representations: representationsVariable }, variableDefinitions), selectionSet));
    return new federation_internals_1.Operation(subgraphSchema, 'query', entitiesCall, variableDefinitions, operationName);
}
function operationForQueryFetch(subgraphSchema, rootKind, selectionSet, allVariableDefinitions, operationName) {
    return new federation_internals_1.Operation(subgraphSchema, rootKind, selectionSet, allVariableDefinitions.filter(selectionSet.usedVariables()), operationName);
}
//# sourceMappingURL=buildPlan.js.map