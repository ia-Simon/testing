package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"go_gql_tests_dog_microservice/database"
	"go_gql_tests_dog_microservice/graph/model"

	"github.com/sirupsen/logrus"
)

// Owner is the resolver for the owner field.
func (r *dogResolver) Owner(ctx context.Context, obj *model.Dog) (*model.User, error) {
	return &model.User{ID: obj.OwnerID}, nil
}

// CreateDog is the resolver for the createDog field.
func (r *mutationResolver) CreateDog(ctx context.Context, input model.CreateDog) (*model.DogMutationPayload, error) {
	logger := logrus.WithContext(ctx).WithFields(logrus.Fields{
		"action": "Mutation#createDog",
		"input":  input,
	})
	logger.Info("Create dog")
	var response model.DogMutationPayload

	dogEntity, err := r.Resolver.DatabaseService.InsertDog(ctx, database.InsertDogInput{
		Name:   input.Name,
		Age:    input.Age,
		UserId: input.OwnerID,
	})
	if err != nil {
		response.Status = false
		response.Errors = append(response.Errors, &model.MutationPayloadError{
			Code:    "DOG00001",
			Message: "Falha ao criar cachorro.",
		})
		logger.WithField("response", response).WithError(err).Error("Failed to create dog.")
		return &response, nil
	}

	response.Status = true
	response.Resource = &model.Dog{
		ID:      dogEntity.Id,
		Name:    dogEntity.Name,
		Age:     dogEntity.Age,
		OwnerID: dogEntity.UserId,
	}

	logger.WithField("response", response).Info("Dog created successfully")
	return &response, nil
}

// Dog is the resolver for the dog field.
func (r *queryResolver) Dog(ctx context.Context, id string) (*model.Dog, error) {
	logger := logrus.WithContext(ctx).WithFields(logrus.Fields{
		"action": "Query#dog",
		"id":     id,
	})
	logger.Info("Find dog by id")

	dogEntity, err := r.Resolver.DatabaseService.FindDogById(ctx, id)
	if err != nil {
		logger.WithError(err).Error("Failed to retrieve dog")
		return nil, nil
	}

	if dogEntity == nil {
		logger.Info("Dog not found")
		return nil, nil
	}

	dog := &model.Dog{
		ID:      dogEntity.Id,
		Name:    dogEntity.Name,
		Age:     dogEntity.Age,
		OwnerID: dogEntity.UserId,
	}

	logger.WithField("response", dog).Info("Dog found successfully")
	return dog, nil
}

// Dogs is the resolver for the dogs field.
func (r *queryResolver) Dogs(ctx context.Context, page int, size int) (*model.DogPagination, error) {
	logger := logrus.WithContext(ctx).WithFields(logrus.Fields{
		"action": "Query#dogs",
		"page":   page,
		"size":   size,
	})
	logger.Info("List dogs")
	var response model.DogPagination

	response.Page = page
	response.Size = size

	dogEntities, total, err := r.Resolver.DatabaseService.FindDogs(ctx, page, size)
	if err != nil {
		logger.WithError(err).Error("Failed to retrieve dogs")
		return &response, err
	}

	for _, dogEntity := range dogEntities {
		response.Items = append(response.Items, &model.Dog{
			ID:      dogEntity.Id,
			Name:    dogEntity.Name,
			Age:     dogEntity.Age,
			OwnerID: dogEntity.UserId,
		})
	}
	response.Total = total

	logger.WithField("response", response).Info("Dogs retrieved successfully")
	return &response, nil
}

// Dog returns DogResolver implementation.
func (r *Resolver) Dog() DogResolver { return &dogResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type dogResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
